"""
Implementation Agent - Generates Flutter/Dart code based on architectural decisions.
"""

import asyncio
import os
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
from .base_agent import BaseAgent
from shared.state import shared_state, AgentStatus, MessageType
from tools import ToolResult, ToolStatus

class ImplementationAgent(BaseAgent):
    """
    The Implementation Agent specializes in generating Flutter/Dart code.
    It transforms architectural decisions into working code using LLM ONLY.
    """
    
    def __init__(self):
        super().__init__("implementation")
        # COMPLETELY REMOVED: No hardcoded templates - everything generated via LLM
        self._flutter_templates = None  # No templates - LLM generates all code
        
    @property
    def flutter_templates(self):
        """No hardcoded templates - all code generated by LLM agents."""
        return {}  # Empty - LLM generates all code based on context
        
    async def execute_task(self, task_description: str, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute implementation tasks."""
        try:
            # Analyze task using LLM to understand implementation requirements
            analysis = await self.think(f"Analyze this implementation task: {task_description}", {
                "task_data": task_data,
                "project_id": task_data.get("project_id", ""),
                "current_files": task_data.get("current_files", [])
            })
            
            self.logger.info(f"🛠️ Implementation Agent executing task: {task_description}")
            
            # Execute appropriate task with retry mechanism
            result = None
            if "implement_feature" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._implement_feature(task_data)
                )
            elif "generate_models" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._generate_models(task_data)
                )
            elif "create_screens" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._create_screens(task_data)
                )
            elif "implement_state_management" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._implement_state_management(task_data)
                )
            elif "setup_project_structure" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._setup_project_structure(task_data)
                )
            elif "fix_implementation_issue" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._fix_implementation_issue(task_data)
                )
            elif "implement_incremental_features" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._implement_incremental_features(task_data)
                )
            elif "implement_incremental" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._implement_incremental_features(task_data)
                )
            elif "validate_feature" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._validate_feature(task_data)
                )
            elif "rollback_feature" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._rollback_feature(task_data)
                )
            elif "create_flutter_project" in task_description:
                result = await self.safe_execute_with_retry(
                    lambda: self._setup_project_structure(task_data)
                )
            else:
                result = await self.safe_execute_with_retry(
                    lambda: self._handle_general_implementation(task_description, task_data)
                )
            
            # Add execution metadata
            result.update({
                "task_type": task_description,
                "execution_time": datetime.now().isoformat(),
                "agent": self.agent_id,
                "task_analysis": analysis[:200] + "..." if len(analysis) > 200 else analysis
            })
            
            return result
            
        except Exception as e:
            import traceback
            self.logger.error(f"❌ Error executing implementation task: {str(e)}\n{traceback.format_exc()}")
            return {
                "status": "failed",
                "error": str(e),
                "task_type": task_description,
                "execution_time": datetime.now().isoformat(),
                "agent": self.agent_id
            }
    
    async def collaborate(self, collaboration_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle collaboration requests."""
        if collaboration_type == "code_review":
            return await self._provide_code_review(data)
        elif collaboration_type == "implementation_guidance":
            return await self._provide_implementation_guidance(data)
        elif collaboration_type == "refactor_request":
            return await self._handle_refactor_request(data)
        else:
            return {"status": "unknown_collaboration_type", "type": collaboration_type}
    
    async def on_state_change(self, change_data: Dict[str, Any]) -> None:
        """React to state changes."""
        event = change_data.get("event")
        
        if event == "architecture_completed":
            await self._start_implementation(change_data["project_id"])
        elif event == "file_added":
            await self._analyze_new_file(change_data)
        elif event == "issue_reported":
            # Respond to QA issues if they're related to implementation
            await self._handle_qa_issue(change_data)
    
    async def _implement_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement a specific feature using tools."""
        feature_name = task_data.get("feature_name", "unknown")
        feature_spec = task_data.get("feature_spec", {})
        project_id = task_data.get("project_id")
        
        self.logger.info(f"🔨 Implementing feature: {feature_name}")
        
        # Create project directory structure first
        await self._create_feature_structure(feature_name)
        
        # Generate feature files using tools
        generated_files = []
        
        # Generate models if needed
        if feature_spec.get("models"):
            model_files = await self._generate_feature_models(feature_name, feature_spec["models"])
            generated_files.extend(model_files)
        
        # Generate screens/UI
        if feature_spec.get("screens"):
            screen_files = await self._generate_feature_screens(feature_name, feature_spec["screens"])
            generated_files.extend(screen_files)
        
        # Generate business logic
        if feature_spec.get("business_logic"):
            logic_files = await self._generate_business_logic(feature_name, feature_spec["business_logic"])
            generated_files.extend(logic_files)
        
        # Update pubspec.yaml if dependencies are needed
        if feature_spec.get("dependencies"):
            await self._add_dependencies(feature_spec["dependencies"])
        
        # Format the generated code
        await self.run_command("dart format .")
        
        # Analyze the code for issues
        analysis_result = await self.execute_tool("analysis", operation="dart_analyze")
        
        return {
            "feature_name": feature_name,
            "generated_files": generated_files,
            "status": "completed",
            "analysis_result": analysis_result.data if analysis_result.data else {},
            "issues_found": analysis_result.data.get("total_issues", 0) if analysis_result.data else 0
        }
        
    
    async def _create_feature_structure(self, feature_name: str) -> None:
        """Create directory structure for a feature using file tools."""
        pass  # All code generation should be done via LLM agents
    
    async def _generate_feature_models(self, feature_name: str, models: List[Dict]) -> List[str]:
        """Generate model files for a feature using LLM only."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _generate_feature_screens(self, feature_name: str, screens: List[Dict]) -> List[str]:
        """Generate screen files for a feature."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _generate_business_logic(self, feature_name: str, logic_spec: Dict) -> List[str]:
        """Generate business logic files (BLoC, repositories, etc.)."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _add_dependencies(self, dependencies: List[str]) -> None:
        """Add dependencies to pubspec.yaml using Flutter tool."""
        self.logger.info(f"📦 Adding dependencies: {dependencies}")
        
        # Use Flutter tool to add packages
        add_result = await self.execute_tool("flutter", operation="pub_add", packages=dependencies)
        
        if add_result.status.value == "success":
            self.logger.info("✅ Dependencies added successfully")
            
            # Run pub get to install dependencies
            await self.execute_tool("flutter", operation="pub_get")
        else:
            self.logger.error(f"❌ Failed to add dependencies: {add_result.error}")

    async def _generate_models(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate data models and DTOs."""
        project_id = task_data["project_id"]
        entities = task_data.get("entities", [])
        
        models_prompt = f"""
        Generate Flutter/Dart models for the following entities:
        {entities}
        
        For each model, create:
        
        1. **Entity Class**: Core business entity
        2. **DTO Class**: Data transfer object for API communication
        3. **Serialization**: toJson() and fromJson() methods
        4. **Equality**: Proper equals and hashCode implementation
        5. **Copy Methods**: copyWith() for immutability
        6. **Validation**: Input validation where appropriate
        
        Use these patterns:
        - Immutable classes with final fields
        - Factory constructors for deserialization
        - Proper null safety
        - Json annotations for serialization
        - Equatable for value equality (if using equatable package)
        
        // REMOVED: Example code removed to prevent hardcoded Flutter templates
        // Use LLM-generated examples only
        
        Generate complete, production-ready model files.
        """
        
        models_code = await self.think(models_prompt, {
            "entities": entities,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, models_code)
        
        return {
            "models_generated": entities,
            "files_created": files_created,
            "code": models_code
        }
    
    async def _create_screens(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create UI screens and widgets."""
        project_id = task_data["project_id"]
        screens = task_data.get("screens", [])
        design_system = task_data.get("design_system", {})
        
        screens_prompt = f"""
        Create Flutter UI screens for:
        Screens: {screens}
        Design System: {design_system}
        
        For each screen, create:
        
        1. **Screen Widget**: Main screen StatefulWidget or StatelessWidget
        2. **Custom Widgets**: Reusable components used in the screen
        3. **State Management**: Integration with chosen state management solution
        4. **Responsive Design**: Proper layout for different screen sizes
        5. **Accessibility**: Semantic labels and accessibility features
        6. **Navigation**: Proper navigation implementation
        
        Follow these UI best practices:
        - Use Material Design 3 guidelines
        - Implement proper loading states
        - Handle error states gracefully
        - Use appropriate animations and transitions
        - Optimize for performance (const widgets, etc.)
        - Follow Flutter widget composition patterns
        
        // REMOVED: Example code removed to prevent hardcoded Flutter templates
        // Use LLM-generated examples only
                      // Screen content
                    ],
                  ),
                ),
              ),
            );
          }}
        }}
        
        Create complete, production-ready screen implementations.
        """
        
        screens_code = await self.think(screens_prompt, {
            "screens": screens,
            "design_system": design_system,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, screens_code)
        
        return {
            "screens_created": screens,
            "files_created": files_created,
            "code": screens_code
        }
    
    async def _implement_state_management(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement the chosen state management solution."""
        project_id = task_data["project_id"]
        solution = task_data.get("solution", "bloc")
        features = task_data.get("features", [])
        
        state_management_prompt = f"""
        Implement {solution} state management for these features:
        Features: {features}
        
        Create a complete state management implementation including:
        
        1. **State Classes**: Define application states
        2. **Event Classes**: Define user actions/events (for BLoC)
        3. **Cubit/Bloc Classes**: Business logic implementation
        4. **Repository Integration**: Connect to data layer
        5. **Provider Setup**: Configure providers/injectors
        6. **Widget Integration**: Connect UI to state management
        
        {self.flutter_templates.get(solution, "Use best practices for the chosen solution")}
        
        Ensure the implementation follows:
        - Separation of concerns
        - Testability principles
        - Error handling
        - Loading states
        - Performance optimization
        
        Generate complete, production-ready state management code.
        """
        
        state_code = await self.think(state_management_prompt, {
            "solution": solution,
            "features": features,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, state_code)
        
        return {
            "state_management": solution,
            "features": features,
            "files_created": files_created,
            "code": state_code
        }
    
    async def _setup_project_structure(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Set up the initial project structure using LLM-generated code only."""
        project_id = task_data.get("project_id")
        project_name = task_data.get("name", "flutter_app")
        architecture_style = task_data.get("architecture_style", "clean")
        
        self.logger.info(f"🏗️ Setting up project structure for {project_name}")
        
        # Get project state for context
        project_state = shared_state.get_project_state(project_id)
        
        try:
            # Create Flutter project using tool
            create_result = await self.execute_tool(
                "flutter", 
                operation="create", 
                project_name=project_name
            )
            
            if create_result.status != ToolStatus.SUCCESS:
                self.logger.error(f"Failed to create Flutter project: {create_result.error}")
                return {
                    "status": "failed",
                    "error": create_result.error,
                    "files_created": [],
                    "project_path": ""
                }
            
            project_path = create_result.data.get("project_path", f"flutter_projects/{project_name}")
            
            # Generate project structure via LLM
            structure_prompt = f"""
            Generate a comprehensive Flutter project structure for {architecture_style} architecture.
            
            Project: {project_name}
            Requirements: {project_state.requirements if project_state else []}
            
            Generate directory structure with:
            - Clean Architecture layers (lib/core, lib/features, lib/shared)
            - Proper folder organization for data, domain, presentation
            - Configuration folders
            - Test structure
            - Asset organization
            
            Return as JSON with directories to create and their purposes.
            """
            
            structure_design = await self.think(structure_prompt, {
                "project": project_state.to_dict() if project_state else {},
                "architecture": architecture_style,
                "name": project_name
            })
            
            # Parse and create directories
            files_created = []
            try:
                import json
                structure_data = json.loads(structure_design)
                directories = structure_data.get("directories", [])
                
                for directory in directories:
                    dir_path = directory.get("path", "")
                    if dir_path:
                        full_path = f"{project_path}/{dir_path}"
                        dir_result = await self.execute_tool(
                            "file", 
                            operation="create_directory", 
                            directory=full_path
                        )
                        if dir_result.status == ToolStatus.SUCCESS:
                            files_created.append(full_path)
                            
            except (json.JSONDecodeError, KeyError) as e:
                self.logger.warning(f"Could not parse structure design, creating basic structure: {e}")
                # Create basic Clean Architecture structure
                basic_dirs = [
                    "lib/core/constants",
                    "lib/core/errors", 
                    "lib/core/utils",
                    "lib/core/themes",
                    "lib/features",
                    "lib/shared/widgets",
                    "lib/shared/utils",
                    "test/features",
                    "test/core"
                ]
                
                for directory in basic_dirs:
                    full_path = f"{project_path}/{directory}"
                    dir_result = await self.execute_tool(
                        "file", 
                        operation="create_directory", 
                        directory=full_path
                    )
                    if dir_result.status == ToolStatus.SUCCESS:
                        files_created.append(full_path)
            
            # Generate and create main.dart with proper structure
            main_dart_prompt = f"""
            Generate a Flutter main.dart file for {project_name} with:
            - Proper imports for {architecture_style} architecture
            - App widget setup
            - Theme configuration
            - Route configuration
            - Error handling
            - Material Design 3 support
            """
            
            main_dart_code = await self.think(main_dart_prompt, {
                "project_name": project_name,
                "architecture": architecture_style
            })
            
            main_file_result = await self.execute_tool(
                "file",
                operation="write",
                file_path=f"{project_path}/lib/main.dart",
                content=main_dart_code
            )
            
            if main_file_result.status == ToolStatus.SUCCESS:
                files_created.append(f"{project_path}/lib/main.dart")
            
            # Update shared state
            if project_state:
                shared_state.update_project(
                    project_id,
                    project_path=project_path,
                    architecture_style=architecture_style
                )
            
            self.logger.info(f"✅ Project structure created: {len(files_created)} items")
            
            return {
                "architecture_style": architecture_style,
                "files_created": files_created,
                "project_path": project_path,
                "status": "project_structure_created"
            }
            
        except Exception as e:
            self.logger.error(f"❌ Error setting up project structure: {e}")
            return {
                "status": "failed",
                "error": str(e),
                "files_created": [],
                "project_path": ""
            }
    
    async def _parse_and_create_files(self, project_id: str, code_content: str) -> List[str]:
        """Parse generated code and create actual files in the Flutter project using LLM-generated code only."""
        if not code_content or not code_content.strip():
            return []
            
        # Get project state for file paths
        project_state = shared_state.get_project_state(project_id)
        project_path = project_state.project_path if project_state else f"flutter_projects/project_{project_id}"
        
        try:
            # Use LLM to parse code content into individual files
            parsing_prompt = f"""
            Parse this Flutter/Dart code content into individual files with their proper paths.
            
            Code Content:
            {code_content}
            
            Return JSON with format:
            {{
                "files": [
                    {{
                        "path": "lib/features/feature_name/file.dart",
                        "content": "actual dart code here",
                        "description": "what this file does"
                    }}
                ]
            }}
            
            Ensure:
            - Proper Flutter/Dart file structure
            - Correct imports
            - Valid Dart syntax
            - Appropriate file paths for Clean Architecture
            """
            
            parsed_result = await self.think(parsing_prompt, {
                "project_id": project_id,
                "project_path": project_path,
                "code_content": code_content
            })
            
            created_files = []
            
            try:
                import json
                files_data = json.loads(parsed_result)
                files_list = files_data.get("files", [])
                
                for file_info in files_list:
                    file_path = file_info.get("path", "")
                    file_content = file_info.get("content", "")
                    
                    if file_path and file_content:
                        # Create file using the file tool
                        full_path = f"{project_path}/{file_path}"
                        
                        # Ensure directory exists
                        import os
                        dir_path = os.path.dirname(full_path)
                        dir_result = await self.execute_tool(
                            "file",
                            operation="create_directory",
                            directory=dir_path
                        )
                        
                        # Write the file
                        file_result = await self.execute_tool(
                            "file",
                            operation="write",
                            file_path=full_path,
                            content=file_content
                        )
                        
                        if file_result.status == ToolStatus.SUCCESS:
                            created_files.append(full_path)
                            self.logger.info(f"✅ Created file: {file_path}")
                        else:
                            self.logger.error(f"❌ Failed to create file {file_path}: {file_result.error}")
            
            except json.JSONDecodeError as e:
                self.logger.error(f"❌ Failed to parse LLM response as JSON: {e}")
                # Fallback: try to extract files by common patterns
                created_files = await self._fallback_file_extraction(project_path, code_content)
            
            # Format all created Dart files
            if created_files:
                try:
                    format_result = await self.run_command(f"dart format {project_path}/lib/")
                    if format_result.status == ToolStatus.SUCCESS:
                        self.logger.info("✅ Formatted generated files")
                except Exception as e:
                    self.logger.warning(f"⚠️ Could not format files: {e}")
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error parsing and creating files: {e}")
            return []

    async def _create_actual_file(self, project_path: str, file_path: str, content: str) -> bool:
        """Create actual file using LLM-generated content only."""
        try:
            # Ensure content is not empty
            if not content or not content.strip():
                self.logger.error(f"❌ Cannot create file {file_path}: empty content")
                return False
            
            # Create full path
            import os
            full_path = os.path.join(project_path, file_path)
            
            # Create directory if it doesn't exist
            dir_path = os.path.dirname(full_path)
            dir_result = await self.execute_tool(
                "file",
                operation="create_directory", 
                directory=dir_path
            )
            
            if dir_result.status != ToolStatus.SUCCESS:
                self.logger.error(f"❌ Failed to create directory {dir_path}: {dir_result.error}")
                return False
            
            # Write the file content
            file_result = await self.execute_tool(
                "file",
                operation="write",
                file_path=full_path,
                content=content
            )
            
            if file_result.status == ToolStatus.SUCCESS:
                self.logger.info(f"✅ Created file: {file_path}")
                return True
            else:
                self.logger.error(f"❌ Failed to write file {file_path}: {file_result.error}")
                return False
                
        except Exception as e:
            self.logger.error(f"❌ Error creating file {file_path}: {e}")
            return False
    
    # Template methods removed - all code generated via LLM
    def _get_bloc_template(self) -> str:
        """REMOVED: No hardcoded BLoC template - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via _generate_bloc_files() instead")

    def _get_provider_template(self) -> str:
        """REMOVED: No hardcoded Provider template - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    def _get_riverpod_template(self) -> str:
        """REMOVED: No hardcoded Riverpod template - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    def _get_clean_architecture_template(self) -> str:
        """REMOVED: No hardcoded Clean Architecture template - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    def _get_widget_template(self, widget_type: str) -> str:
        """REMOVED: No hardcoded widget templates - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    def _get_model_template(self, model_name: str) -> str:
        """REMOVED: No hardcoded model templates - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    def _get_repository_template(self, repo_name: str) -> str:
        """REMOVED: No hardcoded repository templates - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via _generate_repository_code() instead")

    def _get_service_template(self, service_name: str) -> str:
        """REMOVED: No hardcoded service templates - use LLM generation only."""
        raise NotImplementedError("Use LLM generation via self.think() instead")

    async def _create_feature_models(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """Generate feature models using LLM only."""
        try:
            feature_name = feature.get("name", "unknown")
            models = feature.get("models", [])
            
            if not models:
                return []
            
            created_files = []
            
            for model in models:
                model_prompt = f"""
                Generate a complete Flutter data model for {feature_name} feature.
                
                Model Specification:
                {model}
                
                Generate:
                - Properties with proper types and null safety
                - fromJson() factory constructor
                - toJson() method
                - copyWith() method
                - Equatable implementation
                - toString() method
                - Proper imports
                - Documentation comments
                
                Follow Clean Architecture - this is a data layer model.
                Return complete, production-ready Dart code.
                """
                
                model_code = await self.think(model_prompt, {
                    "feature": feature_name,
                    "model": model
                })
                
                # Create model file
                model_name = model.get("name", "unknown_model")
                file_path = f"lib/features/{feature_name.lower()}/data/models/{model_name.lower()}_model.dart"
                
                if await self._create_file_with_content(file_path, model_code):
                    created_files.append(file_path)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error creating feature models: {e}")
            return []

    async def _create_feature_ui(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """Generate feature UI using LLM only."""
        try:
            feature_name = feature.get("name", "unknown")
            screens = feature.get("screens", [])
            widgets = feature.get("widgets", [])
            
            created_files = []
            
            # Generate screens
            for screen in screens:
                screen_prompt = f"""
                Generate a complete Flutter screen/page for {feature_name} feature.
                
                Screen Specification:
                {screen}
                
                Generate:
                - StatelessWidget or StatefulWidget as appropriate
                - BLoC integration with BlocBuilder/BlocListener
                - Responsive design
                - Material Design 3 components
                - Proper navigation
                - Error handling UI
                - Loading states
                - Accessibility support
                - Proper imports
                
                Return complete, production-ready Dart code.
                """
                
                screen_code = await self.think(screen_prompt, {
                    "feature": feature_name,
                    "screen": screen
                })
                
                screen_name = screen.get("name", "unknown_screen")
                file_path = f"lib/features/{feature_name.lower()}/presentation/pages/{screen_name.lower()}_page.dart"
                
                if await self._create_file_with_content(file_path, screen_code):
                    created_files.append(file_path)
            
            # Generate custom widgets
            for widget in widgets:
                widget_prompt = f"""
                Generate a custom Flutter widget for {feature_name} feature.
                
                Widget Specification:
                {widget}
                
                Generate:
                - Reusable widget class
                - Proper parameter handling
                - Theme integration
                - Responsive design
                - Documentation comments
                - Proper imports
                
                Return complete, production-ready Dart code.
                """
                
                widget_code = await self.think(widget_prompt, {
                    "feature": feature_name,
                    "widget": widget
                })
                
                widget_name = widget.get("name", "unknown_widget")
                file_path = f"lib/features/{feature_name.lower()}/presentation/widgets/{widget_name.lower()}_widget.dart"
                
                if await self._create_file_with_content(file_path, widget_code):
                    created_files.append(file_path)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error creating feature UI: {e}")
            return []

    async def _create_feature_logic(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """Generate feature business logic using LLM only."""
        try:
            feature_name = feature.get("name", "unknown")
            use_cases = feature.get("use_cases", [])
            repositories = feature.get("repositories", [])
            
            created_files = []
            
            # Generate use cases
            for use_case in use_cases:
                use_case_code = await self._generate_use_case_code(feature_name, use_case)
                
                use_case_name = use_case.get("name", "unknown_use_case")
                file_path = f"lib/features/{feature_name.lower()}/domain/usecases/{use_case_name.lower()}_usecase.dart"
                
                if await self._create_file_with_content(file_path, use_case_code):
                    created_files.append(file_path)
            
            # Generate repository interfaces
            for repo in repositories:
                repo_interface_prompt = f"""
                Generate an abstract repository interface for {feature_name} feature.
                
                Repository Specification:
                {repo}
                
                Generate:
                - Abstract class with method signatures
                - Proper return types (Future<Result<T, Error>>)
                - Documentation comments
                - Proper imports
                
                This is the domain layer interface.
                Return complete, production-ready Dart code.
                """
                
                repo_interface_code = await self.think(repo_interface_prompt, {
                    "feature": feature_name,
                    "repository": repo
                })
                
                repo_name = repo.get("name", "unknown_repository")
                file_path = f"lib/features/{feature_name.lower()}/domain/repositories/{repo_name.lower()}_repository.dart"
                
                if await self._create_file_with_content(file_path, repo_interface_code):
                    created_files.append(file_path)
                
                # Generate repository implementation
                repo_impl_code = await self._generate_repository_code(feature_name, repo)
                impl_file_path = f"lib/features/{feature_name.lower()}/data/repositories/{repo_name.lower()}_repository_impl.dart"
                
                if await self._create_file_with_content(impl_file_path, repo_impl_code):
                    created_files.append(impl_file_path)
            
            # Generate entities
            entities = feature.get("entities", [])
            for entity in entities:
                entity_prompt = f"""
                Generate a domain entity for {feature_name} feature.
                
                Entity Specification:
                {entity}
                
                Generate:
                - Immutable class with required properties
                - Equatable implementation
                - Business logic methods if needed
                - Documentation comments
                - Proper imports
                
                This is a domain layer entity (business object).
                Return complete, production-ready Dart code.
                """
                
                entity_code = await self.think(entity_prompt, {
                    "feature": feature_name,
                    "entity": entity
                })
                
                entity_name = entity.get("name", "unknown_entity")
                file_path = f"lib/features/{feature_name.lower()}/domain/entities/{entity_name.lower()}_entity.dart"
                
                if await self._create_file_with_content(file_path, entity_code):
                    created_files.append(file_path)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error creating feature logic: {e}")
            return []

    async def _create_feature_tests(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """Generate feature tests using LLM only."""
        try:
            feature_name = feature.get("name", "unknown")
            
            created_files = []
            
            # Generate unit tests for use cases
            use_cases = feature.get("use_cases", [])
            for use_case in use_cases:
                test_prompt = f"""
                Generate comprehensive unit tests for a Flutter use case.
                
                Use Case to Test:
                {use_case}
                Feature: {feature_name}
                
                Generate:
                - Test class with proper setup and teardown
                - Mock dependencies using mockito
                - Test success scenarios
                - Test error scenarios
                - Test edge cases
                - Proper assertions
                - Documentation comments
                
                Return complete, production-ready Dart test code.
                """
                
                test_code = await self.think(test_prompt, {
                    "feature": feature_name,
                    "use_case": use_case
                })
                
                use_case_name = use_case.get("name", "unknown_use_case")
                file_path = f"test/features/{feature_name.lower()}/domain/usecases/{use_case_name.lower()}_usecase_test.dart"
                
                if await self._create_file_with_content(file_path, test_code):
                    created_files.append(file_path)
            
            # Generate widget tests for screens
            screens = feature.get("screens", [])
            for screen in screens:
                widget_test_prompt = f"""
                Generate widget tests for a Flutter screen.
                
                Screen to Test:
                {screen}
                Feature: {feature_name}
                
                Generate:
                - Widget test class with proper setup
                - Mock BLoC dependencies
                - Test widget rendering
                - Test user interactions
                - Test different states (loading, success, error)
                - Proper finder and matcher usage
                - Documentation comments
                
                Return complete, production-ready Dart widget test code.
                """
                
                widget_test_code = await self.think(widget_test_prompt, {
                    "feature": feature_name,
                    "screen": screen
                })
                
                screen_name = screen.get("name", "unknown_screen")
                file_path = f"test/features/{feature_name.lower()}/presentation/pages/{screen_name.lower()}_page_test.dart"
                
                if await self._create_file_with_content(file_path, widget_test_code):
                    created_files.append(file_path)
            
            # Generate repository tests
            repositories = feature.get("repositories", [])
            for repo in repositories:
                repo_test_prompt = f"""
                Generate tests for a repository implementation.
                
                Repository to Test:
                {repo}
                Feature: {feature_name}
                
                Generate:
                - Test class with proper setup
                - Mock data sources
                - Test all repository methods
                - Test success and error scenarios
                - Test data transformation
                - Proper assertions
                - Documentation comments
                
                Return complete, production-ready Dart test code.
                """
                
                repo_test_code = await self.think(repo_test_prompt, {
                    "feature": feature_name,
                    "repository": repo
                })
                
                repo_name = repo.get("name", "unknown_repository")
                file_path = f"test/features/{feature_name.lower()}/data/repositories/{repo_name.lower()}_repository_impl_test.dart"
                
                if await self._create_file_with_content(file_path, repo_test_code):
                    created_files.append(file_path)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error creating feature tests: {e}")
            return []

    async def _create_basic_flutter_app(self, project_path: str, project_name: str) -> List[str]:
        """Generate basic Flutter app structure using LLM only."""
        try:
            created_files = []
            
            # Generate main.dart
            main_prompt = f"""
            Generate a complete main.dart file for a Flutter app named {project_name}.
            
            Generate:
            - Main function with proper app initialization
            - MyApp widget with MaterialApp setup
            - Theme configuration (light and dark)
            - Router configuration
            - Error handling
            - Material Design 3 support
            - Proper imports
            
            Return complete, production-ready Dart code.
            """
            
            main_code = await self.think(main_prompt, {
                "project_name": project_name,
                "project_path": project_path
            })
            
            main_file = f"{project_path}/lib/main.dart"
            if await self._create_file_with_content(main_file, main_code):
                created_files.append(main_file)
            
            # Generate app theme
            theme_prompt = f"""
            Generate a comprehensive theme configuration for Flutter app {project_name}.
            
            Generate:
            - AppTheme class with light and dark themes
            - Color scheme definition
            - Typography configuration
            - Component themes (buttons, cards, etc.)
            - Material Design 3 support
            - Custom theme extensions if needed
            
            Return complete, production-ready Dart code.
            """
            
            theme_code = await self.think(theme_prompt, {
                "project_name": project_name
            })
            
            theme_file = f"{project_path}/lib/core/themes/app_theme.dart"
            if await self._create_file_with_content(theme_file, theme_code):
                created_files.append(theme_file)
            
            # Generate app constants
            constants_prompt = f"""
            Generate app constants for Flutter app {project_name}.
            
            Generate:
            - App-wide constants (strings, dimensions, durations)
            - API constants
            - Asset paths
            - Route names
            - Error messages
            - Configuration values
            
            Return complete, production-ready Dart code.
            """
            
            constants_code = await self.think(constants_prompt, {
                "project_name": project_name
            })
            
            constants_file = f"{project_path}/lib/core/constants/app_constants.dart"
            if await self._create_file_with_content(constants_file, constants_code):
                created_files.append(constants_file)
            
            # Generate error classes
            errors_prompt = f"""
            Generate custom error classes for Flutter app {project_name}.
            
            Generate:
            - Base exception class
            - Network exceptions
            - Validation exceptions
            - Business logic exceptions
            - Error handling utilities
            
            Return complete, production-ready Dart code.
            """
            
            errors_code = await self.think(errors_prompt, {
                "project_name": project_name
            })
            
            errors_file = f"{project_path}/lib/core/errors/exceptions.dart"
            if await self._create_file_with_content(errors_file, errors_code):
                created_files.append(errors_file)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error creating basic Flutter app: {e}")
            return []

    async def _generate_repository_code(self, feature_name: str, repo_spec: Dict[str, Any]) -> str:
        """Generate repository implementation code using LLM only."""
        try:
            repository_prompt = f"""
            Generate a complete Flutter repository implementation for the {feature_name} feature.
            
            Repository Specification:
            {repo_spec}
            
            Generate:
            1. Abstract repository interface
            2. Repository implementation class
            3. Data source integration
            4. Error handling with custom exceptions
            5. Model mapping (entity <-> model)
            6. Proper imports and dependencies
            
            Follow Clean Architecture principles:
            - Repository interface in domain layer
            - Implementation in data layer
            - Dependency injection ready
            - Result pattern for error handling
            - Proper null safety
            
            Return complete, production-ready Dart code.
            """
            
            repository_code = await self.think(repository_prompt, {
                "feature_name": feature_name,
                "specification": repo_spec,
                "architecture": "clean"
            })
            
            return repository_code
            
        except Exception as e:
            self.logger.error(f"❌ Error generating repository code: {e}")
            return f"// Error generating repository code: {e}"

    async def _generate_use_case_code(self, feature_name: str, use_case: Dict[str, Any]) -> str:
        """Generate use case implementation code using LLM only."""
        try:
            use_case_prompt = f"""
            Generate a complete Flutter use case implementation for the {feature_name} feature.
            
            Use Case Specification:
            {use_case}
            
            Generate:
            1. Use case class with call method
            2. Input/output parameters
            3. Repository dependency injection
            4. Business logic implementation
            5. Error handling
            6. Result pattern implementation
            7. Proper imports and types
            
            Follow Clean Architecture principles:
            - Single responsibility
            - Dependency inversion
            - Testable design
            - Result/Either pattern for error handling
            - Proper null safety
            
            Return complete, production-ready Dart code.
            """
            
            use_case_code = await self.think(use_case_prompt, {
                "feature_name": feature_name,
                "use_case": use_case,
                "architecture": "clean"
            })
            
            return use_case_code
            
        except Exception as e:
            self.logger.error(f"❌ Error generating use case code: {e}")
            return f"// Error generating use case code: {e}"

    async def _generate_bloc_files(self, feature_name: str, logic_spec: Dict[str, Any]) -> List[str]:
        """Generate BLoC files for a feature using LLM only."""
        try:
            # Generate BLoC events
            events_prompt = f"""
            Generate Flutter BLoC events for the {feature_name} feature.
            
            Logic Specification:
            {logic_spec}
            
            Generate:
            - Abstract base event class
            - Concrete event classes for each user action
            - Proper equatable implementation
            - Input validation
            - Documentation comments
            
            Return complete, production-ready Dart code for events.
            """
            
            events_code = await self.think(events_prompt, {
                "feature_name": feature_name,
                "logic_spec": logic_spec
            })
            
            # Generate BLoC states
            states_prompt = f"""
            Generate Flutter BLoC states for the {feature_name} feature.
            
            Logic Specification:
            {logic_spec}
            
            Generate:
            - Abstract base state class
            - Loading, success, error states
            - Data holding states
            - Proper equatable implementation
            - Immutable design
            - Documentation comments
            
            Return complete, production-ready Dart code for states.
            """
            
            states_code = await self.think(states_prompt, {
                "feature_name": feature_name,
                "logic_spec": logic_spec
            })
            
            # Generate BLoC implementation
            bloc_prompt = f"""
            Generate Flutter BLoC implementation for the {feature_name} feature.
            
            Logic Specification:
            {logic_spec}
            
            Generate:
            - BLoC class extending Bloc<Event, State>
            - Event handlers for each event type
            - Use case dependency injection
            - Proper error handling
            - Stream transformers if needed
            - Documentation comments
            
            Return complete, production-ready Dart code for BLoC.
            """
            
            bloc_code = await self.think(bloc_prompt, {
                "feature_name": feature_name,
                "logic_spec": logic_spec,
                "events": events_code,
                "states": states_code
            })
            
            # Create the files
            created_files = []
            feature_path = f"lib/features/{feature_name.lower()}/presentation/bloc"
            
            # Create events file
            events_file = f"{feature_path}/{feature_name.lower()}_event.dart"
            if await self._create_file_with_content(events_file, events_code):
                created_files.append(events_file)
            
            # Create states file  
            states_file = f"{feature_path}/{feature_name.lower()}_state.dart"
            if await self._create_file_with_content(states_file, states_code):
                created_files.append(states_file)
            
            # Create bloc file
            bloc_file = f"{feature_path}/{feature_name.lower()}_bloc.dart"
            if await self._create_file_with_content(bloc_file, bloc_code):
                created_files.append(bloc_file)
            
            return created_files
            
        except Exception as e:
            self.logger.error(f"❌ Error generating BLoC files: {e}")
            return []

    async def _implement_incremental_features(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement features incrementally with validation at each step."""
        project_id = task_data["project_id"]
        requirements = task_data.get("requirements", [])
        features = task_data.get("features", [])
        
        self.logger.info(f"🔄 Starting incremental feature implementation for project {project_id}")
        
        # Register with supervision
        await self._register_incremental_process(project_id)
        
        try:
            # Parse requirements into discrete features
            feature_queue = await self._parse_requirements_into_features(requirements, features)
            
            # Initialize incremental state
            shared_state.initialize_incremental_implementation(project_id, feature_queue)
            
            # Sort features by priority and dependencies
            sorted_features = await self._sort_features_by_dependencies(feature_queue)
            
            implementation_results = {
                "project_id": project_id,
                "total_features": len(sorted_features),
                "completed_features": [],
                "failed_features": [],
                "feature_results": {},
                "overall_status": "in_progress"
            }
            
            # Implement features one by one
            for feature in sorted_features:
                feature_id = feature["id"]
                
                self.logger.info(f"🔄 Implementing feature: {feature_id}")
                shared_state.start_feature_implementation(project_id, feature)
                
                # Send heartbeat to supervision
                await self._send_implementation_heartbeat(project_id, feature_id)
                
                # Implement the feature
                feature_result = await self._implement_single_feature(project_id, feature)
                implementation_results["feature_results"][feature_id] = feature_result
                
                if feature_result.get("status") == "success":
                    # Validate the feature
                    validation_result = await self._validate_implemented_feature(project_id, feature)
                    
                    if validation_result["valid"]:
                        # Create rollback point
                        rollback_point = await self._create_rollback_point(project_id, feature_id)
                        
                        # Mark feature as completed
                        shared_state.complete_feature_implementation(
                            project_id, feature_id, True, rollback_point
                        )
                        implementation_results["completed_features"].append(feature_id)
                        
                        self.logger.info(f"✅ Feature {feature_id} implemented and validated successfully")
                    else:
                        # Validation failed - attempt retry or rollback
                        retry_result = await self._handle_feature_validation_failure(
                            project_id, feature, validation_result
                        )
                        
                        if retry_result["success"]:
                            implementation_results["completed_features"].append(feature_id)
                        else:
                            implementation_results["failed_features"].append(feature_id)
                            shared_state.complete_feature_implementation(project_id, feature_id, False)
                else:
                    # Implementation failed
                    implementation_results["failed_features"].append(feature_id)
                    shared_state.complete_feature_implementation(project_id, feature_id, False)
                    
                    self.logger.error(f"❌ Feature {feature_id} implementation failed")
                
                # Check if we should continue or halt
                if len(implementation_results["failed_features"]) > 3:
                    self.logger.error("❌ Too many feature failures, halting incremental implementation")
                    break
            
            # Determine overall status
            total_completed = len(implementation_results["completed_features"])
            total_features = implementation_results["total_features"]
            
            if total_completed == total_features:
                implementation_results["overall_status"] = "completed"
            elif total_completed > 0:
                implementation_results["overall_status"] = "partial"
            else:
                implementation_results["overall_status"] = "failed"
            
            self.logger.info(f"🔄 Incremental implementation completed: {total_completed}/{total_features} features")
            
            return {
                "status": "incremental_implementation_completed",
                "results": implementation_results
            }
        
        except Exception as e:
            self.logger.error(f"❌ Incremental implementation failed: {e}")
            return {
                "status": "incremental_implementation_failed",
                "error": str(e)
            }
    
    async def _parse_requirements_into_features(self, requirements: List[str], features: List[str]) -> List[Dict[str, Any]]:
        """Parse project requirements into discrete, implementable features."""
        feature_queue = []
        
        # Combine requirements and features
        all_features = features + [req for req in requirements if req not in features]
        
        for i, feature_name in enumerate(all_features):
            # Create feature object with metadata
            feature = {
                "id": f"feature_{i+1}_{feature_name.lower().replace(' ', '_')}",
                "name": feature_name,
                "description": f"Implementation of {feature_name}",
                "priority": self._determine_feature_priority(feature_name),
                "dependencies": self._determine_feature_dependencies(feature_name, all_features),
                "estimated_complexity": self._estimate_feature_complexity(feature_name),
                "validation_criteria": self._define_validation_criteria(feature_name),
                "implementation_plan": await self._create_feature_implementation_plan(feature_name)
            }
            feature_queue.append(feature)
        
        return feature_queue
    
    def _determine_feature_priority(self, feature_name: str) -> int:
        """Determine feature priority (1=high, 5=low)."""
        high_priority_keywords = ["auth", "login", "core", "main", "basic", "essential"]
        medium_priority_keywords = ["ui", "interface", "navigation", "data"]
        
        feature_lower = feature_name.lower()
        
        if any(keyword in feature_lower for keyword in high_priority_keywords):
            return 1
        elif any(keyword in feature_lower for keyword in medium_priority_keywords):
            return 3
        else:
            return 4
    
    def _determine_feature_dependencies(self, feature_name: str, all_features: List[str]) -> List[str]:
        """Determine which other features this feature depends on."""
        dependencies = []
        feature_lower = feature_name.lower()
        
        # Simple dependency detection based on keywords
        if "profile" in feature_lower or "user" in feature_lower:
            for other_feature in all_features:
                if "auth" in other_feature.lower() or "login" in other_feature.lower():
                    dependencies.append(other_feature)
        
        if "social" in feature_lower or "sharing" in feature_lower:
            for other_feature in all_features:
                if "auth" in other_feature.lower() or "user" in other_feature.lower():
                    dependencies.append(other_feature)
        
        return dependencies
    
    def _estimate_feature_complexity(self, feature_name: str) -> str:
        """Estimate feature implementation complexity."""
        complex_keywords = ["social", "payment", "ai", "ml", "algorithm", "advanced"]
        medium_keywords = ["api", "database", "integration", "sync"]
        
        feature_lower = feature_name.lower()
        
        if any(keyword in feature_lower for keyword in complex_keywords):
            return "high"
        elif any(keyword in feature_lower for keyword in medium_keywords):
            return "medium"
        else:
            return "low"
    
    def _define_validation_criteria(self, feature_name: str) -> List[str]:
        """Define validation criteria for a feature."""
        base_criteria = ["compiles_successfully", "no_runtime_errors", "basic_functionality"]
        
        feature_lower = feature_name.lower()
        
        if "auth" in feature_lower:
            base_criteria.extend(["login_flow", "logout_flow", "token_validation"])
        elif "ui" in feature_lower or "screen" in feature_lower:
            base_criteria.extend(["renders_correctly", "responsive_design", "navigation_works"])
        elif "api" in feature_lower or "network" in feature_lower:
            base_criteria.extend(["api_calls_work", "error_handling", "data_validation"])
        
        return base_criteria
    
    async def _create_feature_implementation_plan(self, feature_name: str) -> Dict[str, Any]:
        """Create implementation plan for a feature."""
        return {
            "steps": [
                f"Design {feature_name} architecture",
                f"Implement {feature_name} models",
                f"Create {feature_name} UI components",
                f"Add {feature_name} business logic",
                f"Test {feature_name} functionality"
            ],
            "estimated_time": "2-4 hours",
            "files_to_create": [
                f"lib/features/{feature_name.lower()}/",
                f"lib/features/{feature_name.lower()}/models/",
                f"lib/features/{feature_name.lower()}/widgets/",
                f"lib/features/{feature_name.lower()}/services/"
            ]
        }
    
    async def _sort_features_by_dependencies(self, feature_queue: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Sort features by dependencies using topological sort."""
        # Simple topological sort implementation
        sorted_features = []
        remaining_features = feature_queue.copy()
        
        while remaining_features:
            # Find features with no unresolved dependencies
            ready_features = []
            
            for feature in remaining_features:
                dependencies = feature.get("dependencies", [])
                dependencies_met = all(
                    any(completed["name"] == dep for completed in sorted_features)
                    for dep in dependencies
                )
                
                if dependencies_met:
                    ready_features.append(feature)
            
            if not ready_features:
                # Break circular dependencies by priority
                ready_features = [min(remaining_features, key=lambda f: f["priority"])]
            
            # Sort ready features by priority
            ready_features.sort(key=lambda f: f["priority"])
            
            # Add to sorted list and remove from remaining
            for feature in ready_features:
                sorted_features.append(feature)
                remaining_features.remove(feature)
        
        return sorted_features
    
    async def _implement_single_feature(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Implement a single feature with supervision integration."""
        feature_id = feature["id"]
        feature_name = feature["name"]
        
        try:
            # Register feature implementation process
            process_id = await self._register_feature_process(project_id, feature_id)
            
            implementation_result = {
                "feature_id": feature_id,
                "status": "in_progress",
                "files_created": [],
                "errors": [],
                "implementation_time": 0
            }
            
            start_time = datetime.now()
            
            # Execute implementation plan
            plan = feature.get("implementation_plan", {})
            steps = plan.get("steps", [])
            
            for step in steps:
                self.logger.info(f"🔄 Executing step: {step}")
                
                # Send heartbeat
                await self._send_implementation_heartbeat(project_id, feature_id)
                
                # Execute step (simplified implementation)
                step_result = await self._execute_implementation_step(project_id, feature, step)
                
                if step_result.get("files_created"):
                    implementation_result["files_created"].extend(step_result["files_created"])
                
                if step_result.get("errors"):
                    implementation_result["errors"].extend(step_result["errors"])
                    implementation_result["status"] = "failed"
                    break
            
            if implementation_result["status"] != "failed":
                implementation_result["status"] = "success"
            
            implementation_result["implementation_time"] = (datetime.now() - start_time).total_seconds()
            
            # Mark process as completed
            shared_state.mark_process_completed(process_id)
            
            return implementation_result
        
        except Exception as e:
            self.logger.error(f"❌ Feature {feature_id} implementation error: {e}")
            return {
                "feature_id": feature_id,
                "status": "error",
                "error": str(e)
            }
    
    async def _execute_implementation_step(self, project_id: str, feature: Dict[str, Any], step: str) -> Dict[str, Any]:
        """Execute a single implementation step."""
        step_result = {
            "step": step,
            "status": "completed",
            "files_created": [],
            "errors": []
        }
        
        # Simplified step execution
        try:
            if "models" in step.lower():
                # Create models for the feature
                model_files = await self._create_feature_models(project_id, feature)
                step_result["files_created"].extend(model_files)
            
            elif "ui" in step.lower() or "components" in step.lower():
                # Create UI components
                ui_files = await self._create_feature_ui(project_id, feature)
                step_result["files_created"].extend(ui_files)
            
            elif "logic" in step.lower() or "business" in step.lower():
                # Create business logic
                logic_files = await self._create_feature_logic(project_id, feature)
                step_result["files_created"].extend(logic_files)
            
            elif "test" in step.lower():
                # Create tests for the feature
                test_files = await self._create_feature_tests(project_id, feature)
                step_result["files_created"].extend(test_files)
        
        except Exception as e:
            step_result["status"] = "failed"
            step_result["errors"].append(str(e))
        
        return step_result
    
    async def _validate_implemented_feature(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Validate that an implemented feature meets criteria."""
        validation_result = {
            "valid": True,
            "feature_id": feature["id"],
            "criteria_results": {},
            "validation_time": 0
        }
        
        start_time = datetime.now()
        
        try:
            criteria = feature.get("validation_criteria", [])
            
            for criterion in criteria:
                result = await self._validate_single_criterion(project_id, feature, criterion)
                validation_result["criteria_results"][criterion] = result
                
                if not result.get("passed", False):
                    validation_result["valid"] = False
            
            validation_result["validation_time"] = (datetime.now() - start_time).total_seconds()
            
        except Exception as e:
            validation_result["valid"] = False
            validation_result["error"] = str(e)
        
        return validation_result
    
    async def _validate_single_criterion(self, project_id: str, feature: Dict[str, Any], criterion: str) -> Dict[str, Any]:
        """Validate a single criterion for a feature."""
        if criterion == "compiles_successfully":
            return await self._validate_compilation(project_id)
        elif criterion == "no_runtime_errors":
            return await self._validate_runtime(project_id)
        elif criterion == "basic_functionality":
            return await self._validate_basic_functionality(project_id, feature)
        else:
            # Default validation
            return {"passed": True, "details": "Basic validation passed"}
    
    async def _validate_compilation(self, project_id: str) -> Dict[str, Any]:
        """Validate that the project compiles successfully."""
        try:
            # Use Flutter tool to analyze
            analysis_result = await self.execute_tool(
                "flutter",
                operation="analyze",
                timeout=30
            )
            
            return {
                "passed": analysis_result.status.value == "success",
                "details": "Flutter analyze completed",
                "output": analysis_result.data if analysis_result.data else ""
            }
        except Exception as e:
            return {
                "passed": False,
                "details": f"Compilation validation failed: {str(e)}"
            }
    
    async def _validate_runtime(self, project_id: str) -> Dict[str, Any]:
        """Validate runtime behavior."""
        # Simplified runtime validation
        return {
            "passed": True,
            "details": "Runtime validation passed (simplified)"
        }
    
    async def _validate_basic_functionality(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Validate basic functionality of the feature."""
        # Simplified functionality validation
        return {
            "passed": True,
            "details": f"Basic functionality validation for {feature['name']} passed"
        }
    
    async def _create_rollback_point(self, project_id: str, feature_id: str) -> str:
        """Create a Git rollback point for the feature."""
        try:
            # Create git commit for the feature
            commit_result = await self.execute_tool(
                "git",
                operation="commit",
                message=f"Implement feature: {feature_id}",
                add_all=True
            )
            
            if commit_result.status.value == "success":
                # Get commit hash
                hash_result = await self.execute_tool(
                    "git",
                    operation="get_current_commit_hash"
                )
                
                return hash_result.data.strip() if hash_result.data else "unknown"
            else:
                return "commit_failed"
        
        except Exception as e:
            self.logger.error(f"❌ Failed to create rollback point: {e}")
            return "rollback_point_failed"
    
    async def _handle_feature_validation_failure(self, project_id: str, feature: Dict[str, Any], 
                                                validation_result: Dict[str, Any]) -> Dict[str, Any]:
        """Handle feature validation failure with retry logic."""
        feature_id = feature["id"]
        max_retries = 3
        
        for attempt in range(max_retries):
            self.logger.warning(f"⚠️ Feature {feature_id} validation failed, attempt {attempt + 1}")
            
            # Try to fix validation issues
            fix_result = await self._attempt_feature_fix(project_id, feature, validation_result)
            
            if fix_result["success"]:
                # Re-validate
                new_validation = await self._validate_implemented_feature(project_id, feature)
                
                if new_validation["valid"]:
                    return {"success": True, "attempts": attempt + 1}
            
            # If fix failed or validation still fails, wait before retry
            await asyncio.sleep(2)
        
        # All retries failed - rollback
        rollback_result = await self._rollback_to_previous_state(project_id, feature_id)
        
        return {
            "success": False,
            "attempts": max_retries,
            "rollback_performed": rollback_result["success"]
        }
    
    async def _attempt_feature_fix(self, project_id: str, feature: Dict[str, Any], 
                                  validation_result: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt to fix feature validation issues."""
        # Simplified fix attempt
        try:
            failed_criteria = [
                criterion for criterion, result in validation_result["criteria_results"].items()
                if not result.get("passed", False)
            ]
            
            for criterion in failed_criteria:
                if criterion == "compiles_successfully":
                    # Try to fix compilation errors
                    await self._fix_compilation_errors(project_id)
                elif criterion == "no_runtime_errors":
                    # Try to fix runtime errors
                    await self._fix_runtime_errors(project_id)
            
            return {"success": True}
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _fix_compilation_errors(self, project_id: str):
        """Attempt to fix compilation errors."""
        # Simplified compilation fix
        self.logger.info("🔧 Attempting to fix compilation errors")
    
    async def _fix_runtime_errors(self, project_id: str):
        """Attempt to fix runtime errors."""
        # Simplified runtime fix
        self.logger.info("🔧 Attempting to fix runtime errors")
    
    async def _rollback_to_previous_state(self, project_id: str, feature_id: str) -> Dict[str, Any]:
        """Rollback to the previous state before feature implementation."""
        try:
            incremental_state = shared_state.get_incremental_state(project_id)
            
            if incremental_state and feature_id in incremental_state.rollback_points:
                rollback_hash = incremental_state.rollback_points[feature_id]
                
                # Perform git rollback
                rollback_result = await self.execute_tool(
                    "git",
                    operation="reset_hard",
                    commit_hash=rollback_hash
                )
                
                if rollback_result.status.value == "success":
                    self.logger.info(f"🔄 Rolled back feature {feature_id} to {rollback_hash}")
                    return {"success": True, "rollback_hash": rollback_hash}
            
            return {"success": False, "reason": "No rollback point found"}
        
        except Exception as e:
            self.logger.error(f"❌ Rollback failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def _validate_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate a specific feature implementation."""
        project_id = task_data["project_id"]
        feature_id = task_data["feature_id"]
        
        # Get feature from incremental state
        incremental_state = shared_state.get_incremental_state(project_id)
        
        if not incremental_state:
            return {"status": "no_incremental_state"}
        
        # Find the feature
        feature = None
        for f in incremental_state.feature_queue:
            if f["id"] == feature_id:
                feature = f
                break
        
        if not feature:
            return {"status": "feature_not_found"}
        
        # Perform validation
        validation_result = await self._validate_implemented_feature(project_id, feature)
        
        return {
            "status": "validation_completed",
            "feature_id": feature_id,
            "validation_result": validation_result
        }
    
    async def _rollback_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Rollback a specific feature."""
        project_id = task_data["project_id"]
        feature_id = task_data["feature_id"]
        
        rollback_result = await self._rollback_to_previous_state(project_id, feature_id)
        
        return {
            "status": "rollback_completed",
            "feature_id": feature_id,
            "rollback_result": rollback_result
        }
    
    # Supervision integration methods
    async def _register_incremental_process(self, project_id: str):
        """Register incremental implementation process with supervision."""
        try:
            supervision_agent = shared_state.get_agent_state("supervision")
            if supervision_agent:
                await self.collaborate_with_agent(
                    "supervision",
                    "register_process",
                    {
                        "agent_id": self.agent_id,
                        "task_type": "incremental_implementation",
                        "timeout_threshold": 1800,  # 30 minutes
                        "project_id": project_id
                    }
                )
        except Exception as e:
            self.logger.debug(f"Could not register with supervision: {e}")
    
    async def _register_feature_process(self, project_id: str, feature_id: str) -> str:
        """Register individual feature implementation with supervision."""
        process_id = f"feature_{feature_id}_{uuid.uuid4().hex[:8]}"
        
        try:
            shared_state.register_supervised_process(
                process_id=process_id,
                agent_id=self.agent_id,
                task_type="feature_implementation",
                timeout_threshold=600  # 10 minutes per feature
            )
        except Exception as e:
            self.logger.debug(f"Could not register feature process: {e}")
        
        return process_id
    
    async def _send_implementation_heartbeat(self, project_id: str, feature_id: str):
        """Send heartbeat during feature implementation."""
        try:
            self.send_message_to_agent(
                to_agent="supervision",
                message_type=MessageType.HEARTBEAT,
                content={
                    "project_id": project_id,
                    "feature_id": feature_id,
                    "agent_id": self.agent_id,
                    "timestamp": datetime.now().isoformat()
                }
            )
        except Exception as e:
            self.logger.debug(f"Could not send heartbeat: {e}")

    # Real-time awareness and proactive collaboration overrides
    def _react_to_peer_activity(self, peer_agent: str, activity_type: str, 
                               activity_details: Dict[str, Any], consciousness_update: Dict[str, Any]) -> None:
        """React to peer agent activities with proactive collaboration."""
        
        # Architecture decisions → Prepare implementation
        if peer_agent == "architecture" and activity_type == "architecture_decision_made":
            self._prepare_for_architecture_changes(activity_details, consciousness_update)
        
        # Testing started → Provide implementation insights
        elif peer_agent == "testing" and activity_type in ["test_planning", "test_execution_started"]:
            self._assist_with_test_insights(activity_details)
        
        # Security findings → Address implementation security
        elif peer_agent == "security" and activity_type == "security_issue_found":
            self._address_security_in_implementation(activity_details)
        
        # Performance optimization → Optimize implementation
        elif peer_agent == "performance" and activity_type == "performance_issue_detected":
            self._optimize_implementation_performance(activity_details)
    
    def _prepare_for_architecture_changes(self, architecture_details: Dict[str, Any], consciousness: Dict[str, Any]) -> None:
        """Proactively prepare for architecture changes."""
        self.logger.info(f"🏗️ Preparing implementation for architecture changes...")
        
        # Broadcast preparation activity
        self.broadcast_activity(
            activity_type="implementation_preparation",
            activity_details={
                "trigger": "architecture_decision",
                "architecture_changes": architecture_details,
                "preparation_actions": [
                    "analyzing_architecture_impact",
                    "preparing_implementation_strategy",
                    "identifying_affected_components"
                ]
            },
            impact_level="high",
            collaboration_relevance=["testing", "security", "performance"]
        )
        
        # Extract key architecture decisions
        design_patterns = architecture_details.get("design_patterns", [])
        technology_choices = architecture_details.get("technology_choices", {})
        
        # Update shared consciousness with implementation readiness
        shared_state.update_shared_consciousness(
            "implementation_readiness",
            {
                "architecture_understood": True,
                "implementation_strategy": "ready",
                "estimated_complexity": self._estimate_implementation_complexity(architecture_details),
                "ready_for_features": True
            }
        )
    
    def _assist_with_test_insights(self, test_details: Dict[str, Any]) -> None:
        """Proactively assist testing with implementation insights."""
        self.logger.info(f"🧪 Providing implementation insights for testing...")
        
        # Get current implementation state
        current_project_id = shared_state.get_current_project_id()
        if current_project_id:
            project_state = shared_state.get_project_state(current_project_id)
            
            implementation_insights = {
                "files_created": len(project_state.files_created) if project_state else 0,
                "features_implemented": self._get_implemented_features(),
                "testing_recommendations": self._generate_testing_recommendations(),
                "known_edge_cases": self._identify_implementation_edge_cases()
            }
            
            # Broadcast insights to testing agent
            self.broadcast_activity(
                activity_type="implementation_insights_shared",
                activity_details={
                    "trigger": "testing_activity",
                    "insights": implementation_insights,
                    "suggested_test_focus": self._suggest_test_focus_areas()
                },
                impact_level="medium",
                collaboration_relevance=["testing"]
            )
    
    def _address_security_in_implementation(self, security_details: Dict[str, Any]) -> None:
        """Proactively address security issues in implementation."""
        self.logger.info(f"🔒 Addressing security concerns in implementation...")
        
        security_issue_type = security_details.get("issue_type", "")
        affected_files = security_details.get("affected_files", [])
        
        # Plan security fixes
        security_actions = {
            "immediate_actions": [],
            "preventive_measures": [],
            "code_changes_needed": []
        }
        
        if "authentication" in security_issue_type.lower():
            security_actions["immediate_actions"].append("review_auth_implementation")
            security_actions["code_changes_needed"].append("strengthen_auth_validation")
        
        if "data_validation" in security_issue_type.lower():
            security_actions["immediate_actions"].append("add_input_sanitization")
            security_actions["code_changes_needed"].append("implement_data_validation")
        
        # Broadcast security response
        self.broadcast_activity(
            activity_type="security_response_initiated",
            activity_details={
                "trigger": "security_finding",
                "security_issue": security_details,
                "planned_actions": security_actions,
                "implementation_changes": "in_progress"
            },
            impact_level="high",
            collaboration_relevance=["security", "testing"]
        )
    
    def _optimize_implementation_performance(self, performance_details: Dict[str, Any]) -> None:
        """Proactively optimize implementation for performance."""
        self.logger.info(f"⚡ Optimizing implementation for performance...")
        
        performance_issue = performance_details.get("issue_type", "")
        metrics = performance_details.get("metrics", {})
        
        optimization_plan = {
            "code_optimizations": [],
            "architecture_improvements": [],
            "implementation_changes": []
        }
        
        if "memory" in performance_issue.lower():
            optimization_plan["code_optimizations"].extend([
                "optimize_memory_usage",
                "implement_object_pooling",
                "reduce_memory_allocations"
            ])
        
        if "startup_time" in performance_issue.lower():
            optimization_plan["code_optimizations"].extend([
                "lazy_loading",
                "reduce_initialization_overhead",
                "optimize_critical_path"
            ])
        
        # Broadcast optimization activity
        self.broadcast_activity(
            activity_type="performance_optimization_started",
            activity_details={
                "trigger": "performance_issue",
                "performance_data": performance_details,
                "optimization_plan": optimization_plan,
                "expected_improvements": self._estimate_performance_improvements(performance_issue)
            },
            impact_level="medium",
            collaboration_relevance=["performance", "testing"]
        )
    
    def _estimate_implementation_complexity(self, architecture_details: Dict[str, Any]) -> str:
        """Estimate implementation complexity based on architecture."""
        layers = len(architecture_details.get("layers", []))
        patterns = len(architecture_details.get("design_patterns", []))
        
        complexity_score = layers + patterns
        
        if complexity_score <= 3:
            return "low"
        elif complexity_score <= 6:
            return "medium"
        else:
            return "high"
    
    def _get_implemented_features(self) -> List[str]:
        """Get list of currently implemented features."""
        # Simplified implementation - in practice, would analyze actual files
        current_project_id = shared_state.get_current_project_id()
        if current_project_id:
            incremental_state = shared_state.get_incremental_state(current_project_id)
            if incremental_state:
                return incremental_state.completed_features
        return []
    
    def _generate_testing_recommendations(self) -> List[str]:
        """Generate testing recommendations based on implementation."""
        return [
            "focus_on_state_management_tests",
            "test_error_handling_paths",
            "validate_data_flow_integrity",
            "test_ui_component_interactions"
        ]
    
    def _identify_implementation_edge_cases(self) -> List[str]:
        """Identify edge cases in current implementation."""
        return [
            "null_safety_edge_cases",
            "async_operation_timing",
            "state_synchronization_issues",
            "navigation_edge_cases"
        ]
    
    def _suggest_test_focus_areas(self) -> List[str]:
        """Suggest areas for testing to focus on."""
        return [
            "recently_implemented_features",
            "complex_business_logic",
            "integration_points",
            "error_recovery_scenarios"
        ]
    
    def _estimate_performance_improvements(self, issue_type: str) -> Dict[str, str]:
        """Estimate expected performance improvements."""
        improvements = {
            "memory": "10-30% reduction in memory usage",
            "startup_time": "20-50% faster startup",
            "render_performance": "improved frame rate"
        }
        
        return improvements.get(issue_type.lower(), {"general": "5-15% performance improvement"})
    
    async def _create_file_with_content(self, file_path: str, content: str) -> bool:
        """Helper method to create a file with LLM-generated content."""
        try:
            if not content or not content.strip():
                self.logger.error(f"❌ Cannot create file {file_path}: empty content")
                return False
            
            # Get project state for base path
            project_id = getattr(self, '_current_project_id', None)
            if project_id:
                project_state = shared_state.get_project_state(project_id)
                project_path = project_state.project_path if project_state else "flutter_projects"
            else:
                project_path = "flutter_projects"
            
            # Create full path
            import os
            full_path = os.path.join(project_path, file_path)
            
            # Create directory if needed
            dir_path = os.path.dirname(full_path)
            dir_result = await self.execute_tool(
                "file",
                operation="create_directory",
                directory=dir_path
            )
            
            if dir_result.status != ToolStatus.SUCCESS:
                self.logger.error(f"❌ Failed to create directory {dir_path}")
                return False
            
            # Write file
            file_result = await self.execute_tool(
                "file",
                operation="write",
                file_path=full_path,
                content=content
            )
            
            if file_result.status == ToolStatus.SUCCESS:
                self.logger.info(f"✅ Created file: {file_path}")
                return True
            else:
                self.logger.error(f"❌ Failed to write file {file_path}: {file_result.error}")
                return False
                
        except Exception as e:
            return False
    
    async def _fallback_file_extraction(self, project_path: str, code_content: str) -> List[str]:
        """Fallback method to extract files from code content when JSON parsing fails."""
        created_files = []
        
        try:
            # Simple pattern matching for Dart files
            import re
            
            # Look for file patterns like "// lib/path/file.dart" followed by code
            file_pattern = r'(?://\s*)(lib/[^\n]+\.dart)(?:\n|\r\n)((?:.*(?:\n|\r\n))*?)(?=//\s*lib/|$)'
            matches = re.findall(file_pattern, code_content, re.MULTILINE | re.DOTALL)
            
            for file_path, file_content in matches:
                if file_content.strip():
                    full_path = f"{project_path}/{file_path}"
                    
                    # Create directory
                    import os
                    dir_path = os.path.dirname(full_path)
                    await self.execute_tool("file", operation="create_directory", directory=dir_path)
                    
                    # Write file
                    result = await self.execute_tool(
                        "file",
                        operation="write", 
                        file_path=full_path,
                        content=file_content.strip()
                    )
                    
                    if result.status == ToolStatus.SUCCESS:
                        created_files.append(full_path)
            
        except Exception as e:
            self.logger.error(f"❌ Fallback file extraction failed: {e}")
        
        return created_files


