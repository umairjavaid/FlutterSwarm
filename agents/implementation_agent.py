"""
Implementation Agent - Generates Flutter/Dart code based on architectural decisions.
"""

import asyncio
import os
import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
from .base_agent import BaseAgent
from shared.state import shared_state, AgentStatus, MessageType
from tools import ToolResult, ToolStatus

class ImplementationAgent(BaseAgent):
    """
    The Implementation Agent specializes in generating Flutter/Dart code.
    It transforms architectural decisions into working code using LLM ONLY.
    """
    
    def __init__(self):
        super().__init__("implementation")
        # COMPLETELY REMOVED: No hardcoded templates - everything generated via LLM
        self._flutter_templates = None  # No templates - LLM generates all code
        
    @property
    def flutter_templates(self):
        """No hardcoded templates - all code generated by LLM agents."""
        return {}  # Empty - LLM generates all code based on context
        
    async def execute_task(self, task_description: str, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Execute implementation tasks."""
        if "implement_feature" in task_description:
            return await self._implement_feature(task_data)
        elif "generate_models" in task_description:
            return await self._generate_models(task_data)
        elif "create_screens" in task_description:
            return await self._create_screens(task_data)
        elif "implement_state_management" in task_description:
            return await self._implement_state_management(task_data)
        elif "setup_project_structure" in task_description:
            return await self._setup_project_structure(task_data)
        elif "fix_implementation_issue" in task_description:
            return await self._fix_implementation_issue(task_data)
        elif "implement_incremental_features" in task_description:
            return await self._implement_incremental_features(task_data)
        elif "validate_feature" in task_description:
            return await self._validate_feature(task_data)
        elif "rollback_feature" in task_description:
            return await self._rollback_feature(task_data)
        elif "create_flutter_project" in task_description:
            return await self._setup_project_structure(task_data)
        else:
            return await self._handle_general_implementation(task_description, task_data)
    
    async def collaborate(self, collaboration_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle collaboration requests."""
        if collaboration_type == "code_review":
            return await self._provide_code_review(data)
        elif collaboration_type == "implementation_guidance":
            return await self._provide_implementation_guidance(data)
        elif collaboration_type == "refactor_request":
            return await self._handle_refactor_request(data)
        else:
            return {"status": "unknown_collaboration_type", "type": collaboration_type}
    
    async def on_state_change(self, change_data: Dict[str, Any]) -> None:
        """React to state changes."""
        event = change_data.get("event")
        
        if event == "architecture_completed":
            await self._start_implementation(change_data["project_id"])
        elif event == "file_added":
            await self._analyze_new_file(change_data)
        elif event == "issue_reported":
            # Respond to QA issues if they're related to implementation
            await self._handle_qa_issue(change_data)
    
    async def _implement_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement a specific feature using tools."""
        feature_name = task_data.get("feature_name", "unknown")
        feature_spec = task_data.get("feature_spec", {})
        project_id = task_data.get("project_id")
        
        self.logger.info(f"ðŸ”¨ Implementing feature: {feature_name}")
        
        # Create project directory structure first
        await self._create_feature_structure(feature_name)
        
        # Generate feature files using tools
        generated_files = []
        
        # Generate models if needed
        if feature_spec.get("models"):
            model_files = await self._generate_feature_models(feature_name, feature_spec["models"])
            generated_files.extend(model_files)
        
        # Generate screens/UI
        if feature_spec.get("screens"):
            screen_files = await self._generate_feature_screens(feature_name, feature_spec["screens"])
            generated_files.extend(screen_files)
        
        # Generate business logic
        if feature_spec.get("business_logic"):
            logic_files = await self._generate_business_logic(feature_name, feature_spec["business_logic"])
            generated_files.extend(logic_files)
        
        # Update pubspec.yaml if dependencies are needed
        if feature_spec.get("dependencies"):
            await self._add_dependencies(feature_spec["dependencies"])
        
        # Format the generated code
        await self.run_command("dart format .")
        
        # Analyze the code for issues
        analysis_result = await self.execute_tool("analysis", operation="dart_analyze")
        
        return {
            "feature_name": feature_name,
            "generated_files": generated_files,
            "status": "completed",
            "analysis_result": analysis_result.data if analysis_result.data else {},
            "issues_found": analysis_result.data.get("total_issues", 0) if analysis_result.data else 0
        }
        
    
    async def _create_feature_structure(self, feature_name: str) -> None:
        """Create directory structure for a feature using file tools."""
        pass  # All code generation should be done via LLM agents
    
    async def _generate_feature_models(self, feature_name: str, models: List[Dict]) -> List[str]:
        """Generate model files for a feature using LLM only."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _generate_feature_screens(self, feature_name: str, screens: List[Dict]) -> List[str]:
        """Generate screen files for a feature."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _generate_business_logic(self, feature_name: str, logic_spec: Dict) -> List[str]:
        """Generate business logic files (BLoC, repositories, etc.)."""
        pass  # All code generation should be done via LLM agents
        return []
    
    async def _add_dependencies(self, dependencies: List[str]) -> None:
        """Add dependencies to pubspec.yaml using Flutter tool."""
        self.logger.info(f"ðŸ“¦ Adding dependencies: {dependencies}")
        
        # Use Flutter tool to add packages
        add_result = await self.execute_tool("flutter", operation="pub_add", packages=dependencies)
        
        if add_result.status.value == "success":
            self.logger.info("âœ… Dependencies added successfully")
            
            # Run pub get to install dependencies
            await self.execute_tool("flutter", operation="pub_get")
        else:
            self.logger.error(f"âŒ Failed to add dependencies: {add_result.error}")

    async def _generate_models(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate data models and DTOs."""
        project_id = task_data["project_id"]
        entities = task_data.get("entities", [])
        
        models_prompt = f"""
        Generate Flutter/Dart models for the following entities:
        {entities}
        
        For each model, create:
        
        1. **Entity Class**: Core business entity
        2. **DTO Class**: Data transfer object for API communication
        3. **Serialization**: toJson() and fromJson() methods
        4. **Equality**: Proper equals and hashCode implementation
        5. **Copy Methods**: copyWith() for immutability
        6. **Validation**: Input validation where appropriate
        
        Use these patterns:
        - Immutable classes with final fields
        - Factory constructors for deserialization
        - Proper null safety
        - Json annotations for serialization
        - Equatable for value equality (if using equatable package)
        
        // REMOVED: Example code removed to prevent hardcoded Flutter templates
        // Use LLM-generated examples only
        
        Generate complete, production-ready model files.
        """
        
        models_code = await self.think(models_prompt, {
            "entities": entities,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, models_code)
        
        return {
            "models_generated": entities,
            "files_created": files_created,
            "code": models_code
        }
    
    async def _create_screens(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create UI screens and widgets."""
        project_id = task_data["project_id"]
        screens = task_data.get("screens", [])
        design_system = task_data.get("design_system", {})
        
        screens_prompt = f"""
        Create Flutter UI screens for:
        Screens: {screens}
        Design System: {design_system}
        
        For each screen, create:
        
        1. **Screen Widget**: Main screen StatefulWidget or StatelessWidget
        2. **Custom Widgets**: Reusable components used in the screen
        3. **State Management**: Integration with chosen state management solution
        4. **Responsive Design**: Proper layout for different screen sizes
        5. **Accessibility**: Semantic labels and accessibility features
        6. **Navigation**: Proper navigation implementation
        
        Follow these UI best practices:
        - Use Material Design 3 guidelines
        - Implement proper loading states
        - Handle error states gracefully
        - Use appropriate animations and transitions
        - Optimize for performance (const widgets, etc.)
        - Follow Flutter widget composition patterns
        
        // REMOVED: Example code removed to prevent hardcoded Flutter templates
        // Use LLM-generated examples only
                      // Screen content
                    ],
                  ),
                ),
              ),
            );
          }}
        }}
        
        Create complete, production-ready screen implementations.
        """
        
        screens_code = await self.think(screens_prompt, {
            "screens": screens,
            "design_system": design_system,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, screens_code)
        
        return {
            "screens_created": screens,
            "files_created": files_created,
            "code": screens_code
        }
    
    async def _implement_state_management(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement the chosen state management solution."""
        project_id = task_data["project_id"]
        solution = task_data.get("solution", "bloc")
        features = task_data.get("features", [])
        
        state_management_prompt = f"""
        Implement {solution} state management for these features:
        Features: {features}
        
        Create a complete state management implementation including:
        
        1. **State Classes**: Define application states
        2. **Event Classes**: Define user actions/events (for BLoC)
        3. **Cubit/Bloc Classes**: Business logic implementation
        4. **Repository Integration**: Connect to data layer
        5. **Provider Setup**: Configure providers/injectors
        6. **Widget Integration**: Connect UI to state management
        
        {self.flutter_templates.get(solution, "Use best practices for the chosen solution")}
        
        Ensure the implementation follows:
        - Separation of concerns
        - Testability principles
        - Error handling
        - Loading states
        - Performance optimization
        
        Generate complete, production-ready state management code.
        """
        
        state_code = await self.think(state_management_prompt, {
            "solution": solution,
            "features": features,
            "project": shared_state.get_project_state(project_id)
        })
        
        files_created = await self._parse_and_create_files(project_id, state_code)
        
        return {
            "state_management": solution,
            "features": features,
            "files_created": files_created,
            "code": state_code
        }
    
    async def _setup_project_structure(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Set up the initial project structure using LLM-generated code only."""
        pass
        # Return minimal structure for compatibility
        return {
            "architecture_style": task_data.get("architecture_style", "clean"),
            "files_created": [],
            "project_path": "",
            "status": "project_structure_created"
        }
    
    async def _parse_and_create_files(self, project_id: str, code_content: str) -> List[str]:
        """Parse generated code and create actual files in the Flutter project using LLM-generated code only."""
        pass
        return []

    async def _create_actual_file(self, project_path: str, file_path: str, content: str) -> bool:
        """Create actual file using LLM-generated content only."""
        pass
        return False
    
    # Remove ALL hardcoded template generation methods
    def _get_bloc_template(self) -> str:
        """REMOVED: No hardcoded BLoC template - use LLM generation only."""
        pass

    def _get_provider_template(self) -> str:
        """REMOVED: No hardcoded Provider template - use LLM generation only."""
        pass

    def _get_riverpod_template(self) -> str:
        """REMOVED: No hardcoded Riverpod template - use LLM generation only."""
        pass

    def _get_clean_architecture_template(self) -> str:
        """REMOVED: No hardcoded Clean Architecture template - use LLM generation only."""
        pass

    def _get_widget_template(self, widget_type: str) -> str:
        """REMOVED: No hardcoded widget templates - use LLM generation only."""
        pass

    def _get_model_template(self, model_name: str) -> str:
        """REMOVED: No hardcoded model templates - use LLM generation only."""
        pass

    def _get_repository_template(self, repo_name: str) -> str:
        """REMOVED: No hardcoded repository templates - use LLM generation only."""
        pass

    def _get_service_template(self, service_name: str) -> str:
        """REMOVED: No hardcoded service templates - use LLM generation only."""
        pass

    async def _create_feature_models(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """REMOVED: No hardcoded model creation - use LLM generation only."""
        pass

    async def _create_feature_ui(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """REMOVED: No hardcoded UI creation - use LLM generation only."""
        pass

    async def _create_feature_logic(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """REMOVED: No hardcoded logic creation - use LLM generation only."""
        pass

    async def _create_feature_tests(self, project_id: str, feature: Dict[str, Any]) -> List[str]:
        """REMOVED: No hardcoded test creation - use LLM generation only."""
        pass

    async def _create_basic_flutter_app(self, project_path: str, project_name: str) -> List[str]:
        """REMOVED: No hardcoded app creation - use LLM generation only."""
        pass

    async def _generate_repository_code(self, feature_name: str, repo_spec: Dict[str, Any]) -> str:
        """Generate repository implementation code using LLM only."""
        pass
        return ""

    async def _generate_use_case_code(self, feature_name: str, use_case: Dict[str, Any]) -> str:
        """Generate use case implementation code using LLM only."""
        pass
        return ""

    async def _generate_bloc_files(self, feature_name: str, logic_spec: Dict[str, Any]) -> List[str]:
        """Generate BLoC files for a feature using LLM only."""
        pass
        return []

    async def _implement_incremental_features(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Implement features incrementally with validation at each step."""
        project_id = task_data["project_id"]
        requirements = task_data.get("requirements", [])
        features = task_data.get("features", [])
        
        self.logger.info(f"ðŸ”„ Starting incremental feature implementation for project {project_id}")
        
        # Register with supervision
        await self._register_incremental_process(project_id)
        
        try:
            # Parse requirements into discrete features
            feature_queue = await self._parse_requirements_into_features(requirements, features)
            
            # Initialize incremental state
            shared_state.initialize_incremental_implementation(project_id, feature_queue)
            
            # Sort features by priority and dependencies
            sorted_features = await self._sort_features_by_dependencies(feature_queue)
            
            implementation_results = {
                "project_id": project_id,
                "total_features": len(sorted_features),
                "completed_features": [],
                "failed_features": [],
                "feature_results": {},
                "overall_status": "in_progress"
            }
            
            # Implement features one by one
            for feature in sorted_features:
                feature_id = feature["id"]
                
                self.logger.info(f"ðŸ”„ Implementing feature: {feature_id}")
                shared_state.start_feature_implementation(project_id, feature)
                
                # Send heartbeat to supervision
                await self._send_implementation_heartbeat(project_id, feature_id)
                
                # Implement the feature
                feature_result = await self._implement_single_feature(project_id, feature)
                implementation_results["feature_results"][feature_id] = feature_result
                
                if feature_result["status"] == "success":
                    # Validate the feature
                    validation_result = await self._validate_implemented_feature(project_id, feature)
                    
                    if validation_result["valid"]:
                        # Create rollback point
                        rollback_point = await self._create_rollback_point(project_id, feature_id)
                        
                        # Mark feature as completed
                        shared_state.complete_feature_implementation(
                            project_id, feature_id, True, rollback_point
                        )
                        implementation_results["completed_features"].append(feature_id)
                        
                        self.logger.info(f"âœ… Feature {feature_id} implemented and validated successfully")
                    else:
                        # Validation failed - attempt retry or rollback
                        retry_result = await self._handle_feature_validation_failure(
                            project_id, feature, validation_result
                        )
                        
                        if retry_result["success"]:
                            implementation_results["completed_features"].append(feature_id)
                        else:
                            implementation_results["failed_features"].append(feature_id)
                            shared_state.complete_feature_implementation(project_id, feature_id, False)
                else:
                    # Implementation failed
                    implementation_results["failed_features"].append(feature_id)
                    shared_state.complete_feature_implementation(project_id, feature_id, False)
                    
                    self.logger.error(f"âŒ Feature {feature_id} implementation failed")
                
                # Check if we should continue or halt
                if len(implementation_results["failed_features"]) > 3:
                    self.logger.error("âŒ Too many feature failures, halting incremental implementation")
                    break
            
            # Determine overall status
            total_completed = len(implementation_results["completed_features"])
            total_features = implementation_results["total_features"]
            
            if total_completed == total_features:
                implementation_results["overall_status"] = "completed"
            elif total_completed > 0:
                implementation_results["overall_status"] = "partial"
            else:
                implementation_results["overall_status"] = "failed"
            
            self.logger.info(f"ðŸ”„ Incremental implementation completed: {total_completed}/{total_features} features")
            
            return {
                "status": "incremental_implementation_completed",
                "results": implementation_results
            }
        
        except Exception as e:
            self.logger.error(f"âŒ Incremental implementation failed: {e}")
            return {
                "status": "incremental_implementation_failed",
                "error": str(e)
            }
    
    async def _parse_requirements_into_features(self, requirements: List[str], features: List[str]) -> List[Dict[str, Any]]:
        """Parse project requirements into discrete, implementable features."""
        feature_queue = []
        
        # Combine requirements and features
        all_features = features + [req for req in requirements if req not in features]
        
        for i, feature_name in enumerate(all_features):
            # Create feature object with metadata
            feature = {
                "id": f"feature_{i+1}_{feature_name.lower().replace(' ', '_')}",
                "name": feature_name,
                "description": f"Implementation of {feature_name}",
                "priority": self._determine_feature_priority(feature_name),
                "dependencies": self._determine_feature_dependencies(feature_name, all_features),
                "estimated_complexity": self._estimate_feature_complexity(feature_name),
                "validation_criteria": self._define_validation_criteria(feature_name),
                "implementation_plan": await self._create_feature_implementation_plan(feature_name)
            }
            feature_queue.append(feature)
        
        return feature_queue
    
    def _determine_feature_priority(self, feature_name: str) -> int:
        """Determine feature priority (1=high, 5=low)."""
        high_priority_keywords = ["auth", "login", "core", "main", "basic", "essential"]
        medium_priority_keywords = ["ui", "interface", "navigation", "data"]
        
        feature_lower = feature_name.lower()
        
        if any(keyword in feature_lower for keyword in high_priority_keywords):
            return 1
        elif any(keyword in feature_lower for keyword in medium_priority_keywords):
            return 3
        else:
            return 4
    
    def _determine_feature_dependencies(self, feature_name: str, all_features: List[str]) -> List[str]:
        """Determine which other features this feature depends on."""
        dependencies = []
        feature_lower = feature_name.lower()
        
        # Simple dependency detection based on keywords
        if "profile" in feature_lower or "user" in feature_lower:
            for other_feature in all_features:
                if "auth" in other_feature.lower() or "login" in other_feature.lower():
                    dependencies.append(other_feature)
        
        if "social" in feature_lower or "sharing" in feature_lower:
            for other_feature in all_features:
                if "auth" in other_feature.lower() or "user" in other_feature.lower():
                    dependencies.append(other_feature)
        
        return dependencies
    
    def _estimate_feature_complexity(self, feature_name: str) -> str:
        """Estimate feature implementation complexity."""
        complex_keywords = ["social", "payment", "ai", "ml", "algorithm", "advanced"]
        medium_keywords = ["api", "database", "integration", "sync"]
        
        feature_lower = feature_name.lower()
        
        if any(keyword in feature_lower for keyword in complex_keywords):
            return "high"
        elif any(keyword in feature_lower for keyword in medium_keywords):
            return "medium"
        else:
            return "low"
    
    def _define_validation_criteria(self, feature_name: str) -> List[str]:
        """Define validation criteria for a feature."""
        base_criteria = ["compiles_successfully", "no_runtime_errors", "basic_functionality"]
        
        feature_lower = feature_name.lower()
        
        if "auth" in feature_lower:
            base_criteria.extend(["login_flow", "logout_flow", "token_validation"])
        elif "ui" in feature_lower or "screen" in feature_lower:
            base_criteria.extend(["renders_correctly", "responsive_design", "navigation_works"])
        elif "api" in feature_lower or "network" in feature_lower:
            base_criteria.extend(["api_calls_work", "error_handling", "data_validation"])
        
        return base_criteria
    
    async def _create_feature_implementation_plan(self, feature_name: str) -> Dict[str, Any]:
        """Create implementation plan for a feature."""
        return {
            "steps": [
                f"Design {feature_name} architecture",
                f"Implement {feature_name} models",
                f"Create {feature_name} UI components",
                f"Add {feature_name} business logic",
                f"Test {feature_name} functionality"
            ],
            "estimated_time": "2-4 hours",
            "files_to_create": [
                f"lib/features/{feature_name.lower()}/",
                f"lib/features/{feature_name.lower()}/models/",
                f"lib/features/{feature_name.lower()}/widgets/",
                f"lib/features/{feature_name.lower()}/services/"
            ]
        }
    
    async def _sort_features_by_dependencies(self, feature_queue: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Sort features by dependencies using topological sort."""
        # Simple topological sort implementation
        sorted_features = []
        remaining_features = feature_queue.copy()
        
        while remaining_features:
            # Find features with no unresolved dependencies
            ready_features = []
            
            for feature in remaining_features:
                dependencies = feature.get("dependencies", [])
                dependencies_met = all(
                    any(completed["name"] == dep for completed in sorted_features)
                    for dep in dependencies
                )
                
                if dependencies_met:
                    ready_features.append(feature)
            
            if not ready_features:
                # Break circular dependencies by priority
                ready_features = [min(remaining_features, key=lambda f: f["priority"])]
            
            # Sort ready features by priority
            ready_features.sort(key=lambda f: f["priority"])
            
            # Add to sorted list and remove from remaining
            for feature in ready_features:
                sorted_features.append(feature)
                remaining_features.remove(feature)
        
        return sorted_features
    
    async def _implement_single_feature(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Implement a single feature with supervision integration."""
        feature_id = feature["id"]
        feature_name = feature["name"]
        
        try:
            # Register feature implementation process
            process_id = await self._register_feature_process(project_id, feature_id)
            
            implementation_result = {
                "feature_id": feature_id,
                "status": "in_progress",
                "files_created": [],
                "errors": [],
                "implementation_time": 0
            }
            
            start_time = datetime.now()
            
            # Execute implementation plan
            plan = feature.get("implementation_plan", {})
            steps = plan.get("steps", [])
            
            for step in steps:
                self.logger.info(f"ðŸ”„ Executing step: {step}")
                
                # Send heartbeat
                await self._send_implementation_heartbeat(project_id, feature_id)
                
                # Execute step (simplified implementation)
                step_result = await self._execute_implementation_step(project_id, feature, step)
                
                if step_result.get("files_created"):
                    implementation_result["files_created"].extend(step_result["files_created"])
                
                if step_result.get("errors"):
                    implementation_result["errors"].extend(step_result["errors"])
                    implementation_result["status"] = "failed"
                    break
            
            if implementation_result["status"] != "failed":
                implementation_result["status"] = "success"
            
            implementation_result["implementation_time"] = (datetime.now() - start_time).total_seconds()
            
            # Mark process as completed
            shared_state.mark_process_completed(process_id)
            
            return implementation_result
        
        except Exception as e:
            self.logger.error(f"âŒ Feature {feature_id} implementation error: {e}")
            return {
                "feature_id": feature_id,
                "status": "error",
                "error": str(e)
            }
    
    async def _execute_implementation_step(self, project_id: str, feature: Dict[str, Any], step: str) -> Dict[str, Any]:
        """Execute a single implementation step."""
        step_result = {
            "step": step,
            "status": "completed",
            "files_created": [],
            "errors": []
        }
        
        # Simplified step execution
        try:
            if "models" in step.lower():
                # Create models for the feature
                model_files = await self._create_feature_models(project_id, feature)
                step_result["files_created"].extend(model_files)
            
            elif "ui" in step.lower() or "components" in step.lower():
                # Create UI components
                ui_files = await self._create_feature_ui(project_id, feature)
                step_result["files_created"].extend(ui_files)
            
            elif "logic" in step.lower() or "business" in step.lower():
                # Create business logic
                logic_files = await self._create_feature_logic(project_id, feature)
                step_result["files_created"].extend(logic_files)
            
            elif "test" in step.lower():
                # Create tests for the feature
                test_files = await self._create_feature_tests(project_id, feature)
                step_result["files_created"].extend(test_files)
        
        except Exception as e:
            step_result["status"] = "failed"
            step_result["errors"].append(str(e))
        
        return step_result
    
    async def _validate_implemented_feature(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Validate that an implemented feature meets criteria."""
        validation_result = {
            "valid": True,
            "feature_id": feature["id"],
            "criteria_results": {},
            "validation_time": 0
        }
        
        start_time = datetime.now()
        
        try:
            criteria = feature.get("validation_criteria", [])
            
            for criterion in criteria:
                result = await self._validate_single_criterion(project_id, feature, criterion)
                validation_result["criteria_results"][criterion] = result
                
                if not result.get("passed", False):
                    validation_result["valid"] = False
            
            validation_result["validation_time"] = (datetime.now() - start_time).total_seconds()
            
        except Exception as e:
            validation_result["valid"] = False
            validation_result["error"] = str(e)
        
        return validation_result
    
    async def _validate_single_criterion(self, project_id: str, feature: Dict[str, Any], criterion: str) -> Dict[str, Any]:
        """Validate a single criterion for a feature."""
        if criterion == "compiles_successfully":
            return await self._validate_compilation(project_id)
        elif criterion == "no_runtime_errors":
            return await self._validate_runtime(project_id)
        elif criterion == "basic_functionality":
            return await self._validate_basic_functionality(project_id, feature)
        else:
            # Default validation
            return {"passed": True, "details": "Basic validation passed"}
    
    async def _validate_compilation(self, project_id: str) -> Dict[str, Any]:
        """Validate that the project compiles successfully."""
        try:
            # Use Flutter tool to analyze
            analysis_result = await self.execute_tool(
                "flutter",
                operation="analyze",
                timeout=30
            )
            
            return {
                "passed": analysis_result.status.value == "success",
                "details": "Flutter analyze completed",
                "output": analysis_result.data if analysis_result.data else ""
            }
        except Exception as e:
            return {
                "passed": False,
                "details": f"Compilation validation failed: {str(e)}"
            }
    
    async def _validate_runtime(self, project_id: str) -> Dict[str, Any]:
        """Validate runtime behavior."""
        # Simplified runtime validation
        return {
            "passed": True,
            "details": "Runtime validation passed (simplified)"
        }
    
    async def _validate_basic_functionality(self, project_id: str, feature: Dict[str, Any]) -> Dict[str, Any]:
        """Validate basic functionality of the feature."""
        # Simplified functionality validation
        return {
            "passed": True,
            "details": f"Basic functionality validation for {feature['name']} passed"
        }
    
    async def _create_rollback_point(self, project_id: str, feature_id: str) -> str:
        """Create a Git rollback point for the feature."""
        try:
            # Create git commit for the feature
            commit_result = await self.execute_tool(
                "git",
                operation="commit",
                message=f"Implement feature: {feature_id}",
                add_all=True
            )
            
            if commit_result.status.value == "success":
                # Get commit hash
                hash_result = await self.execute_tool(
                    "git",
                    operation="get_current_commit_hash"
                )
                
                return hash_result.data.strip() if hash_result.data else "unknown"
            else:
                return "commit_failed"
        
        except Exception as e:
            self.logger.error(f"âŒ Failed to create rollback point: {e}")
            return "rollback_point_failed"
    
    async def _handle_feature_validation_failure(self, project_id: str, feature: Dict[str, Any], 
                                                validation_result: Dict[str, Any]) -> Dict[str, Any]:
        """Handle feature validation failure with retry logic."""
        feature_id = feature["id"]
        max_retries = 3
        
        for attempt in range(max_retries):
            self.logger.warning(f"âš ï¸ Feature {feature_id} validation failed, attempt {attempt + 1}")
            
            # Try to fix validation issues
            fix_result = await self._attempt_feature_fix(project_id, feature, validation_result)
            
            if fix_result["success"]:
                # Re-validate
                new_validation = await self._validate_implemented_feature(project_id, feature)
                
                if new_validation["valid"]:
                    return {"success": True, "attempts": attempt + 1}
            
            # If fix failed or validation still fails, wait before retry
            await asyncio.sleep(2)
        
        # All retries failed - rollback
        rollback_result = await self._rollback_to_previous_state(project_id, feature_id)
        
        return {
            "success": False,
            "attempts": max_retries,
            "rollback_performed": rollback_result["success"]
        }
    
    async def _attempt_feature_fix(self, project_id: str, feature: Dict[str, Any], 
                                  validation_result: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt to fix feature validation issues."""
        # Simplified fix attempt
        try:
            failed_criteria = [
                criterion for criterion, result in validation_result["criteria_results"].items()
                if not result.get("passed", False)
            ]
            
            for criterion in failed_criteria:
                if criterion == "compiles_successfully":
                    # Try to fix compilation errors
                    await self._fix_compilation_errors(project_id)
                elif criterion == "no_runtime_errors":
                    # Try to fix runtime errors
                    await self._fix_runtime_errors(project_id)
            
            return {"success": True}
        
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _fix_compilation_errors(self, project_id: str):
        """Attempt to fix compilation errors."""
        # Simplified compilation fix
        self.logger.info("ðŸ”§ Attempting to fix compilation errors")
    
    async def _fix_runtime_errors(self, project_id: str):
        """Attempt to fix runtime errors."""
        # Simplified runtime fix
        self.logger.info("ðŸ”§ Attempting to fix runtime errors")
    
    async def _rollback_to_previous_state(self, project_id: str, feature_id: str) -> Dict[str, Any]:
        """Rollback to the previous state before feature implementation."""
        try:
            incremental_state = shared_state.get_incremental_state(project_id)
            
            if incremental_state and feature_id in incremental_state.rollback_points:
                rollback_hash = incremental_state.rollback_points[feature_id]
                
                # Perform git rollback
                rollback_result = await self.execute_tool(
                    "git",
                    operation="reset_hard",
                    commit_hash=rollback_hash
                )
                
                if rollback_result.status.value == "success":
                    self.logger.info(f"ðŸ”„ Rolled back feature {feature_id} to {rollback_hash}")
                    return {"success": True, "rollback_hash": rollback_hash}
            
            return {"success": False, "reason": "No rollback point found"}
        
        except Exception as e:
            self.logger.error(f"âŒ Rollback failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def _validate_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate a specific feature implementation."""
        project_id = task_data["project_id"]
        feature_id = task_data["feature_id"]
        
        # Get feature from incremental state
        incremental_state = shared_state.get_incremental_state(project_id)
        
        if not incremental_state:
            return {"status": "no_incremental_state"}
        
        # Find the feature
        feature = None
        for f in incremental_state.feature_queue:
            if f["id"] == feature_id:
                feature = f
                break
        
        if not feature:
            return {"status": "feature_not_found"}
        
        # Perform validation
        validation_result = await self._validate_implemented_feature(project_id, feature)
        
        return {
            "status": "validation_completed",
            "feature_id": feature_id,
            "validation_result": validation_result
        }
    
    async def _rollback_feature(self, task_data: Dict[str, Any]) -> Dict[str, Any]:
        """Rollback a specific feature."""
        project_id = task_data["project_id"]
        feature_id = task_data["feature_id"]
        
        rollback_result = await self._rollback_to_previous_state(project_id, feature_id)
        
        return {
            "status": "rollback_completed",
            "feature_id": feature_id,
            "rollback_result": rollback_result
        }
    
    # Supervision integration methods
    async def _register_incremental_process(self, project_id: str):
        """Register incremental implementation process with supervision."""
        try:
            supervision_agent = shared_state.get_agent_state("supervision")
            if supervision_agent:
                await self.collaborate_with_agent(
                    "supervision",
                    "register_process",
                    {
                        "agent_id": self.agent_id,
                        "task_type": "incremental_implementation",
                        "timeout_threshold": 1800,  # 30 minutes
                        "project_id": project_id
                    }
                )
        except Exception as e:
            self.logger.debug(f"Could not register with supervision: {e}")
    
    async def _register_feature_process(self, project_id: str, feature_id: str) -> str:
        """Register individual feature implementation with supervision."""
        process_id = f"feature_{feature_id}_{uuid.uuid4().hex[:8]}"
        
        try:
            shared_state.register_supervised_process(
                process_id=process_id,
                agent_id=self.agent_id,
                task_type="feature_implementation",
                timeout_threshold=600  # 10 minutes per feature
            )
        except Exception as e:
            self.logger.debug(f"Could not register feature process: {e}")
        
        return process_id
    
    async def _send_implementation_heartbeat(self, project_id: str, feature_id: str):
        """Send heartbeat during feature implementation."""
        try:
            self.send_message_to_agent(
                to_agent="supervision",
                message_type=MessageType.HEARTBEAT,
                content={
                    "project_id": project_id,
                    "feature_id": feature_id,
                    "agent_id": self.agent_id,
                    "timestamp": datetime.now().isoformat()
                }
            )
        except Exception as e:
            self.logger.debug(f"Could not send heartbeat: {e}")

    # Real-time awareness and proactive collaboration overrides
    def _react_to_peer_activity(self, peer_agent: str, activity_type: str, 
                               activity_details: Dict[str, Any], consciousness_update: Dict[str, Any]) -> None:
        """React to peer agent activities with proactive collaboration."""
        
        # Architecture decisions â†’ Prepare implementation
        if peer_agent == "architecture" and activity_type == "architecture_decision_made":
            self._prepare_for_architecture_changes(activity_details, consciousness_update)
        
        # Testing started â†’ Provide implementation insights
        elif peer_agent == "testing" and activity_type in ["test_planning", "test_execution_started"]:
            self._assist_with_test_insights(activity_details)
        
        # Security findings â†’ Address implementation security
        elif peer_agent == "security" and activity_type == "security_issue_found":
            self._address_security_in_implementation(activity_details)
        
        # Performance optimization â†’ Optimize implementation
        elif peer_agent == "performance" and activity_type == "performance_issue_detected":
            self._optimize_implementation_performance(activity_details)
    
    def _prepare_for_architecture_changes(self, architecture_details: Dict[str, Any], consciousness: Dict[str, Any]) -> None:
        """Proactively prepare for architecture changes."""
        self.logger.info(f"ðŸ—ï¸ Preparing implementation for architecture changes...")
        
        # Broadcast preparation activity
        self.broadcast_activity(
            activity_type="implementation_preparation",
            activity_details={
                "trigger": "architecture_decision",
                "architecture_changes": architecture_details,
                "preparation_actions": [
                    "analyzing_architecture_impact",
                    "preparing_implementation_strategy",
                    "identifying_affected_components"
                ]
            },
            impact_level="high",
            collaboration_relevance=["testing", "security", "performance"]
        )
        
        # Extract key architecture decisions
        design_patterns = architecture_details.get("design_patterns", [])
        technology_choices = architecture_details.get("technology_choices", {})
        
        # Update shared consciousness with implementation readiness
        shared_state.update_shared_consciousness(
            "implementation_readiness",
            {
                "architecture_understood": True,
                "implementation_strategy": "ready",
                "estimated_complexity": self._estimate_implementation_complexity(architecture_details),
                "ready_for_features": True
            }
        )
    
    def _assist_with_test_insights(self, test_details: Dict[str, Any]) -> None:
        """Proactively assist testing with implementation insights."""
        self.logger.info(f"ðŸ§ª Providing implementation insights for testing...")
        
        # Get current implementation state
        current_project_id = shared_state.get_current_project_id()
        if current_project_id:
            project_state = shared_state.get_project_state(current_project_id)
            
            implementation_insights = {
                "files_created": len(project_state.files_created) if project_state else 0,
                "features_implemented": self._get_implemented_features(),
                "testing_recommendations": self._generate_testing_recommendations(),
                "known_edge_cases": self._identify_implementation_edge_cases()
            }
            
            # Broadcast insights to testing agent
            self.broadcast_activity(
                activity_type="implementation_insights_shared",
                activity_details={
                    "trigger": "testing_activity",
                    "insights": implementation_insights,
                    "suggested_test_focus": self._suggest_test_focus_areas()
                },
                impact_level="medium",
                collaboration_relevance=["testing"]
            )
    
    def _address_security_in_implementation(self, security_details: Dict[str, Any]) -> None:
        """Proactively address security issues in implementation."""
        self.logger.info(f"ðŸ”’ Addressing security concerns in implementation...")
        
        security_issue_type = security_details.get("issue_type", "")
        affected_files = security_details.get("affected_files", [])
        
        # Plan security fixes
        security_actions = {
            "immediate_actions": [],
            "preventive_measures": [],
            "code_changes_needed": []
        }
        
        if "authentication" in security_issue_type.lower():
            security_actions["immediate_actions"].append("review_auth_implementation")
            security_actions["code_changes_needed"].append("strengthen_auth_validation")
        
        if "data_validation" in security_issue_type.lower():
            security_actions["immediate_actions"].append("add_input_sanitization")
            security_actions["code_changes_needed"].append("implement_data_validation")
        
        # Broadcast security response
        self.broadcast_activity(
            activity_type="security_response_initiated",
            activity_details={
                "trigger": "security_finding",
                "security_issue": security_details,
                "planned_actions": security_actions,
                "implementation_changes": "in_progress"
            },
            impact_level="high",
            collaboration_relevance=["security", "testing"]
        )
    
    def _optimize_implementation_performance(self, performance_details: Dict[str, Any]) -> None:
        """Proactively optimize implementation for performance."""
        self.logger.info(f"âš¡ Optimizing implementation for performance...")
        
        performance_issue = performance_details.get("issue_type", "")
        metrics = performance_details.get("metrics", {})
        
        optimization_plan = {
            "code_optimizations": [],
            "architecture_improvements": [],
            "implementation_changes": []
        }
        
        if "memory" in performance_issue.lower():
            optimization_plan["code_optimizations"].extend([
                "optimize_memory_usage",
                "implement_object_pooling",
                "reduce_memory_allocations"
            ])
        
        if "startup_time" in performance_issue.lower():
            optimization_plan["code_optimizations"].extend([
                "lazy_loading",
                "reduce_initialization_overhead",
                "optimize_critical_path"
            ])
        
        # Broadcast optimization activity
        self.broadcast_activity(
            activity_type="performance_optimization_started",
            activity_details={
                "trigger": "performance_issue",
                "performance_data": performance_details,
                "optimization_plan": optimization_plan,
                "expected_improvements": self._estimate_performance_improvements(performance_issue)
            },
            impact_level="medium",
            collaboration_relevance=["performance", "testing"]
        )
    
    def _estimate_implementation_complexity(self, architecture_details: Dict[str, Any]) -> str:
        """Estimate implementation complexity based on architecture."""
        layers = len(architecture_details.get("layers", []))
        patterns = len(architecture_details.get("design_patterns", []))
        
        complexity_score = layers + patterns
        
        if complexity_score <= 3:
            return "low"
        elif complexity_score <= 6:
            return "medium"
        else:
            return "high"
    
    def _get_implemented_features(self) -> List[str]:
        """Get list of currently implemented features."""
        # Simplified implementation - in practice, would analyze actual files
        current_project_id = shared_state.get_current_project_id()
        if current_project_id:
            incremental_state = shared_state.get_incremental_state(current_project_id)
            if incremental_state:
                return incremental_state.completed_features
        return []
    
    def _generate_testing_recommendations(self) -> List[str]:
        """Generate testing recommendations based on implementation."""
        return [
            "focus_on_state_management_tests",
            "test_error_handling_paths",
            "validate_data_flow_integrity",
            "test_ui_component_interactions"
        ]
    
    def _identify_implementation_edge_cases(self) -> List[str]:
        """Identify edge cases in current implementation."""
        return [
            "null_safety_edge_cases",
            "async_operation_timing",
            "state_synchronization_issues",
            "navigation_edge_cases"
        ]
    
    def _suggest_test_focus_areas(self) -> List[str]:
        """Suggest areas for testing to focus on."""
        return [
            "recently_implemented_features",
            "complex_business_logic",
            "integration_points",
            "error_recovery_scenarios"
        ]
    
    def _estimate_performance_improvements(self, issue_type: str) -> Dict[str, str]:
        """Estimate expected performance improvements."""
        improvements = {
            "memory": "10-30% reduction in memory usage",
            "startup_time": "20-50% faster startup",
            "render_performance": "improved frame rate"
        }
        
        return improvements.get(issue_type.lower(), {"general": "5-15% performance improvement"})


